{"version":3,"file":"debouncer.js","sources":["../../src/debouncer.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { AnyFunction } from './types'\n\nexport interface DebouncerState<TFn extends AnyFunction> {\n  /**\n   * Whether the debouncer can execute on the leading edge of the timeout\n   */\n  canLeadingExecute: boolean\n  /**\n   * Number of function executions that have been completed\n   */\n  executionCount: number\n  /**\n   * Whether the debouncer is waiting for the timeout to trigger execution\n   */\n  isPending: boolean\n  /**\n   * The arguments from the most recent call to maybeExecute\n   */\n  lastArgs: Parameters<TFn> | undefined\n  /**\n   * Number of times maybeExecute has been called (for reduction calculations)\n   */\n  maybeExecuteCount: number\n  /**\n   * Current execution status - 'idle' when not active, 'pending' when waiting for timeout\n   */\n  status: 'disabled' | 'idle' | 'pending'\n}\n\nfunction getDefaultDebouncerState<\n  TFn extends AnyFunction,\n>(): DebouncerState<TFn> {\n  return {\n    canLeadingExecute: true,\n    executionCount: 0,\n    isPending: false,\n    lastArgs: undefined,\n    status: 'idle',\n    maybeExecuteCount: 0,\n  }\n}\n\n/**\n * Options for configuring a debounced function\n */\nexport interface DebouncerOptions<TFn extends AnyFunction> {\n  /**\n   * Whether the debouncer is enabled. When disabled, maybeExecute will not trigger any executions.\n   * Can be a boolean or a function that returns a boolean.\n   * Defaults to true.\n   */\n  enabled?: boolean | ((debouncer: Debouncer<TFn>) => boolean)\n  /**\n   * Initial state for the debouncer\n   */\n  initialState?: Partial<DebouncerState<TFn>>\n  /**\n   * A key to identify the debouncer.\n   * If provided, the debouncer will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Whether to execute on the leading edge of the timeout.\n   * The first call will execute immediately and the rest will wait the delay.\n   * Defaults to false.\n   */\n  leading?: boolean\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, debouncer: Debouncer<TFn>) => void\n  /**\n   * Whether to execute on the trailing edge of the timeout.\n   * Defaults to true.\n   */\n  trailing?: boolean\n  /**\n   * Delay in milliseconds before executing the function.\n   * Can be a number or a function that returns a number.\n   * Defaults to 0ms\n   */\n  wait: number | ((debouncer: Debouncer<TFn>) => number)\n}\n\nconst defaultOptions: Omit<\n  Required<DebouncerOptions<any>>,\n  'initialState' | 'onExecute' | 'key'\n> = {\n  enabled: true,\n  leading: false,\n  trailing: true,\n  wait: 0,\n}\n\n/**\n * A class that creates a debounced function.\n *\n * Debouncing ensures that a function is only executed after a certain amount of time has passed\n * since its last invocation. This is useful for handling frequent events like window resizing,\n * scroll events, or input changes where you want to limit the rate of execution.\n *\n * The debounced function can be configured to execute either at the start of the delay period\n * (leading edge) or at the end (trailing edge, default). Each new call during the wait period\n * will reset the timer.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the debouncer\n * - Use `onExecute` callback to react to function execution and implement custom logic\n * - The state includes canLeadingExecute, execution count, and isPending status\n * - State can be accessed via `debouncer.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `debouncer.state`\n *\n * @example\n * ```ts\n * const debouncer = new Debouncer((value: string) => {\n *   saveToDatabase(value);\n * }, { wait: 500 });\n *\n * // Will only save after 500ms of no new input\n * inputElement.addEventListener('input', () => {\n *   debouncer.maybeExecute(inputElement.value);\n * });\n * ```\n */\nexport class Debouncer<TFn extends AnyFunction> {\n  readonly store: Store<Readonly<DebouncerState<TFn>>> = new Store(\n    getDefaultDebouncerState<TFn>(),\n  )\n  key: string\n  options: DebouncerOptions<TFn>\n  #timeoutId: NodeJS.Timeout | undefined\n\n  constructor(\n    public fn: TFn,\n    initialOptions: DebouncerOptions<TFn>,\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n    }\n    this.#setState(this.options.initialState ?? {})\n\n    pacerEventClient.on('d-Debouncer', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state as DebouncerState<TFn>)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the debouncer options\n   */\n  setOptions = (newOptions: Partial<DebouncerOptions<TFn>>): void => {\n    this.options = { ...this.options, ...newOptions }\n\n    // Cancel pending execution if the debouncer is disabled\n    if (!this.#getEnabled()) {\n      this.cancel()\n    }\n  }\n\n  #setState = (newState: Partial<DebouncerState<TFn>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n      const { isPending } = combinedState\n      return {\n        ...combinedState,\n        status: !this.#getEnabled()\n          ? 'disabled'\n          : isPending\n            ? 'pending'\n            : 'idle',\n      }\n    })\n    emitChange('Debouncer', this)\n  }\n\n  /**\n   * Returns the current enabled state of the debouncer\n   */\n  #getEnabled = (): boolean => {\n    return !!parseFunctionOrValue(this.options.enabled, this)\n  }\n\n  /**\n   * Returns the current wait time in milliseconds\n   */\n  #getWait = (): number => {\n    return parseFunctionOrValue(this.options.wait, this)\n  }\n\n  /**\n   * Attempts to execute the debounced function\n   * If a call is already in progress, it will be queued\n   */\n  maybeExecute = (...args: Parameters<TFn>): void => {\n    if (!this.#getEnabled()) return undefined\n\n    this.#setState({\n      maybeExecuteCount: this.store.state.maybeExecuteCount + 1,\n    })\n\n    let _didLeadingExecute = false\n\n    // Handle leading execution\n    if (this.options.leading && this.store.state.canLeadingExecute) {\n      this.#setState({ canLeadingExecute: false })\n      _didLeadingExecute = true\n      this.#execute(...args)\n    }\n\n    // Start pending state to indicate that the debouncer is waiting for the trailing edge\n    if (this.options.trailing) {\n      this.#setState({ isPending: true, lastArgs: args })\n    }\n\n    // Clear any existing timeout\n    if (this.#timeoutId) clearTimeout(this.#timeoutId)\n\n    // Set new timeout that will reset canLeadingExecute and execute trailing only if enabled and did not execute leading\n    this.#timeoutId = setTimeout(() => {\n      this.#setState({ canLeadingExecute: true })\n      if (this.options.trailing && !_didLeadingExecute) {\n        this.#execute(...args)\n      }\n    }, this.#getWait())\n  }\n\n  #execute = (...args: Parameters<TFn>): void => {\n    if (!this.#getEnabled()) return undefined\n    this.fn(...args) // EXECUTE!\n    this.#setState({\n      executionCount: this.store.state.executionCount + 1,\n      isPending: false,\n      lastArgs: undefined,\n    })\n    this.options.onExecute?.(args, this)\n  }\n\n  /**\n   * Processes the current pending execution immediately\n   */\n  flush = (): void => {\n    if (this.store.state.isPending && this.store.state.lastArgs) {\n      this.#clearTimeout() // clear any pending timeout\n      this.#execute(...this.store.state.lastArgs) // execute immediately\n    }\n  }\n\n  #clearTimeout = (): void => {\n    if (this.#timeoutId) {\n      clearTimeout(this.#timeoutId)\n      this.#timeoutId = undefined\n    }\n  }\n\n  /**\n   * Cancels any pending execution\n   */\n  cancel = (): void => {\n    this.#clearTimeout()\n    this.#setState({\n      canLeadingExecute: true,\n      isPending: false,\n    })\n  }\n\n  /**\n   * Resets the debouncer state to its default values\n   */\n  reset = (): void => {\n    this.#setState(getDefaultDebouncerState<TFn>())\n  }\n}\n\n/**\n * Creates a debounced function that delays invoking the provided function until after a specified wait time.\n * Multiple calls during the wait period will cancel previous pending invocations and reset the timer.\n *\n * This the the simple function wrapper implementation pulled from the Debouncer class. If you need\n * more control over the debouncing behavior, use the Debouncer class directly.\n *\n * If leading option is true, the function will execute immediately on the first call, then wait the delay\n * before allowing another execution.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the debouncer\n * - Use `onExecute` callback to react to function execution and implement custom logic\n * - The state includes canLeadingExecute, execution count, and isPending status\n * - State can be accessed via the underlying Debouncer instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * @example\n * ```ts\n * const debounced = debounce(() => {\n *   saveChanges();\n * }, { wait: 1000 });\n *\n * // Called repeatedly but executes at most once per second\n * inputElement.addEventListener('input', debounced);\n * ```\n */\nexport function debounce<TFn extends AnyFunction>(\n  fn: TFn,\n  initialOptions: DebouncerOptions<TFn>,\n): (...args: Parameters<TFn>) => void {\n  const debouncer = new Debouncer(fn, initialOptions)\n  return debouncer.maybeExecute\n}\n"],"names":[],"mappings":";;;AAgCA,SAAS,2BAEgB;AACvB,SAAO;AAAA,IACL,mBAAmB;AAAA,IACnB,gBAAgB;AAAA,IAChB,WAAW;AAAA,IACX,UAAU;AAAA,IACV,QAAQ;AAAA,IACR,mBAAmB;AAAA,EAAA;AAEvB;AA4CA,MAAM,iBAGF;AAAA,EACF,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,EACV,MAAM;AACR;AAiCO,MAAM,UAAmC;AAAA,EAQ9C,YACS,IACP,gBACA;AAFO,SAAA,KAAA;AART,SAAS,QAA8C,IAAI;AAAA,MACzD,yBAAA;AAAA,IAA8B;AA2BhC,SAAA,aAAa,CAAC,eAAqD;AACjE,WAAK,UAAU,EAAE,GAAG,KAAK,SAAS,GAAG,WAAA;AAGrC,UAAI,CAAC,KAAK,eAAe;AACvB,aAAK,OAAA;AAAA,MAAO;AAAA,IACd;AAGF,SAAA,YAAY,CAAC,aAAiD;AAC5D,WAAK,MAAM,SAAS,CAAC,UAAU;AAC7B,cAAM,gBAAgB;AAAA,UACpB,GAAG;AAAA,UACH,GAAG;AAAA,QAAA;AAEL,cAAM,EAAE,cAAc;AACtB,eAAO;AAAA,UACL,GAAG;AAAA,UACH,QAAQ,CAAC,KAAK,gBACV,aACA,YACE,YACA;AAAA,QAAA;AAAA,MACR,CACD;AACD,iBAAW,aAAa,IAAI;AAAA,IAAA;AAM9B,SAAA,cAAc,MAAe;AAC3B,aAAO,CAAC,CAAC,qBAAqB,KAAK,QAAQ,SAAS,IAAI;AAAA,IAAA;AAM1D,SAAA,WAAW,MAAc;AACvB,aAAO,qBAAqB,KAAK,QAAQ,MAAM,IAAI;AAAA,IAAA;AAOrD,SAAA,eAAe,IAAI,SAAgC;AACjD,UAAI,CAAC,KAAK,YAAA,EAAe,QAAO;AAEhC,WAAK,UAAU;AAAA,QACb,mBAAmB,KAAK,MAAM,MAAM,oBAAoB;AAAA,MAAA,CACzD;AAED,UAAI,qBAAqB;AAGzB,UAAI,KAAK,QAAQ,WAAW,KAAK,MAAM,MAAM,mBAAmB;AAC9D,aAAK,UAAU,EAAE,mBAAmB,MAAA,CAAO;AAC3C,6BAAqB;AACrB,aAAK,SAAS,GAAG,IAAI;AAAA,MAAA;AAIvB,UAAI,KAAK,QAAQ,UAAU;AACzB,aAAK,UAAU,EAAE,WAAW,MAAM,UAAU,MAAM;AAAA,MAAA;AAIpD,UAAI,KAAK,WAAY,cAAa,KAAK,UAAU;AAGjD,WAAK,aAAa,WAAW,MAAM;AACjC,aAAK,UAAU,EAAE,mBAAmB,KAAA,CAAM;AAC1C,YAAI,KAAK,QAAQ,YAAY,CAAC,oBAAoB;AAChD,eAAK,SAAS,GAAG,IAAI;AAAA,QAAA;AAAA,MACvB,GACC,KAAK,UAAU;AAAA,IAAA;AAGpB,SAAA,WAAW,IAAI,SAAgC;AAC7C,UAAI,CAAC,KAAK,YAAA,EAAe,QAAO;AAChC,WAAK,GAAG,GAAG,IAAI;AACf,WAAK,UAAU;AAAA,QACb,gBAAgB,KAAK,MAAM,MAAM,iBAAiB;AAAA,QAClD,WAAW;AAAA,QACX,UAAU;AAAA,MAAA,CACX;AACD,WAAK,QAAQ,YAAY,MAAM,IAAI;AAAA,IAAA;AAMrC,SAAA,QAAQ,MAAY;AAClB,UAAI,KAAK,MAAM,MAAM,aAAa,KAAK,MAAM,MAAM,UAAU;AAC3D,aAAK,cAAA;AACL,aAAK,SAAS,GAAG,KAAK,MAAM,MAAM,QAAQ;AAAA,MAAA;AAAA,IAC5C;AAGF,SAAA,gBAAgB,MAAY;AAC1B,UAAI,KAAK,YAAY;AACnB,qBAAa,KAAK,UAAU;AAC5B,aAAK,aAAa;AAAA,MAAA;AAAA,IACpB;AAMF,SAAA,SAAS,MAAY;AACnB,WAAK,cAAA;AACL,WAAK,UAAU;AAAA,QACb,mBAAmB;AAAA,QACnB,WAAW;AAAA,MAAA,CACZ;AAAA,IAAA;AAMH,SAAA,QAAQ,MAAY;AAClB,WAAK,UAAU,0BAA+B;AAAA,IAAA;AA3I9C,SAAK,MAAM,UAAU,eAAe,GAAG;AACvC,SAAK,UAAU;AAAA,MACb,GAAG;AAAA,MACH,GAAG;AAAA,IAAA;AAEL,SAAK,UAAU,KAAK,QAAQ,gBAAgB,CAAA,CAAE;AAE9C,qBAAiB,GAAG,eAAe,CAAC,UAAU;AAC5C,UAAI,MAAM,QAAQ,QAAQ,KAAK,IAAK;AACpC,WAAK,UAAU,MAAM,QAAQ,MAAM,KAA4B;AAC/D,WAAK,WAAW,MAAM,QAAQ,OAAO;AAAA,IAAA,CACtC;AAAA,EAAA;AAAA,EAjBH;AAAA,EAgCA;AAAA,EAsBA;AAAA,EAOA;AAAA,EAyCA;AAAA,EAqBA;AAwBF;AA8BO,SAAS,SACd,IACA,gBACoC;AACpC,QAAM,YAAY,IAAI,UAAU,IAAI,cAAc;AAClD,SAAO,UAAU;AACnB;"}