{"version":3,"file":"async-throttler.js","sources":["../../src/async-throttler.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { AnyAsyncFunction, OptionalKeys } from './types'\n\nexport interface AsyncThrottlerState<TFn extends AnyAsyncFunction> {\n  /**\n   * Number of function executions that have resulted in errors\n   */\n  errorCount: number\n  /**\n   * Whether the throttled function is currently executing asynchronously\n   */\n  isExecuting: boolean\n  /**\n   * Whether the throttler is waiting for the timeout to trigger execution\n   */\n  isPending: boolean\n  /**\n   * The arguments from the most recent call to maybeExecute\n   */\n  lastArgs: Parameters<TFn> | undefined\n  /**\n   * Timestamp of the last function execution in milliseconds\n   */\n  lastExecutionTime: number\n  /**\n   * The result from the most recent successful function execution\n   */\n  lastResult: ReturnType<TFn> | undefined\n  /**\n   * Number of times maybeExecute has been called (for reduction calculations)\n   */\n  maybeExecuteCount: number\n  /**\n   * Timestamp when the next execution can occur in milliseconds\n   */\n  nextExecutionTime: number | undefined\n  /**\n   * Number of function executions that have completed (either successfully or with errors)\n   */\n  settleCount: number\n  /**\n   * Current execution status - 'idle' when not active, 'pending' when waiting, 'executing' when running, 'settled' when completed\n   */\n  status: 'disabled' | 'idle' | 'pending' | 'executing' | 'settled'\n  /**\n   * Number of function executions that have completed successfully\n   */\n  successCount: number\n}\n\nfunction getDefaultAsyncThrottlerState<\n  TFn extends AnyAsyncFunction,\n>(): AsyncThrottlerState<TFn> {\n  return {\n    errorCount: 0,\n    isExecuting: false,\n    isPending: false,\n    lastArgs: undefined,\n    lastExecutionTime: 0,\n    lastResult: undefined,\n    maybeExecuteCount: 0,\n    nextExecutionTime: undefined,\n    settleCount: 0,\n    status: 'idle',\n    successCount: 0,\n  }\n}\n\n/**\n * Options for configuring an async throttled function\n */\nexport interface AsyncThrottlerOptions<TFn extends AnyAsyncFunction> {\n  /**\n   * Whether the throttler is enabled. When disabled, maybeExecute will not trigger any executions.\n   * Can be a boolean or a function that returns a boolean.\n   * Defaults to true.\n   */\n  enabled?: boolean | ((throttler: AsyncThrottler<TFn>) => boolean)\n  /**\n   * Initial state for the async throttler\n   */\n  initialState?: Partial<AsyncThrottlerState<TFn>>\n  /**\n   * Optional key to identify this async throttler instance.\n   * If provided, the async throttler will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Whether to execute the function immediately when called\n   * Defaults to true\n   */\n  leading?: boolean\n  /**\n   * Optional error handler for when the throttled function throws.\n   * If provided, the handler will be called with the error and throttler instance.\n   * This can be used alongside throwOnError - the handler will be called before any error is thrown.\n   */\n  onError?: (\n    error: unknown,\n    args: Parameters<TFn>,\n    asyncThrottler: AsyncThrottler<TFn>,\n  ) => void\n  /**\n   * Optional function to call when the throttled function is executed\n   */\n  onSettled?: (\n    args: Parameters<TFn>,\n    asyncThrottler: AsyncThrottler<TFn>,\n  ) => void\n  /**\n   * Optional function to call when the throttled function is executed\n   */\n  onSuccess?: (\n    result: ReturnType<TFn>,\n    args: Parameters<TFn>,\n    asyncThrottler: AsyncThrottler<TFn>,\n  ) => void\n  /**\n   * Whether to throw errors when they occur.\n   * Defaults to true if no onError handler is provided, false if an onError handler is provided.\n   * Can be explicitly set to override these defaults.\n   */\n  throwOnError?: boolean\n  /**\n   * Whether to execute the function on the trailing edge of the wait period\n   * Defaults to true\n   */\n  trailing?: boolean\n  /**\n   * Time window in milliseconds during which the function can only be executed once.\n   * Can be a number or a function that returns a number.\n   * Defaults to 0ms\n   */\n  wait: number | ((throttler: AsyncThrottler<TFn>) => number)\n}\n\ntype AsyncThrottlerOptionsWithOptionalCallbacks = OptionalKeys<\n  AsyncThrottlerOptions<any>,\n  'initialState' | 'onError' | 'onSettled' | 'onSuccess'\n>\n\nconst defaultOptions: AsyncThrottlerOptionsWithOptionalCallbacks = {\n  enabled: true,\n  leading: true,\n  trailing: true,\n  wait: 0,\n}\n\n/**\n * A class that creates an async throttled function.\n *\n * Throttling limits how often a function can be executed, allowing only one execution within a specified time window.\n * Unlike debouncing which resets the delay timer on each call, throttling ensures the function executes at a\n * regular interval regardless of how often it's called.\n *\n * Unlike the non-async Throttler, this async version supports returning values from the throttled function,\n * making it ideal for API calls and other async operations where you want the result of the `maybeExecute` call\n * instead of setting the result on a state variable from within the throttled function.\n *\n * This is useful for rate-limiting API calls, handling scroll/resize events, or any scenario where you want to\n * ensure a maximum execution frequency.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and throttler instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together - the handler will be called before any error is thrown\n * - The error state can be checked using the underlying AsyncThrottler instance\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the async throttler\n * - Use `onSuccess` callback to react to successful function execution and implement custom logic\n * - Use `onError` callback to react to function execution errors and implement custom error handling\n * - Use `onSettled` callback to react to function execution completion (success or error) and implement custom logic\n * - The state includes error count, execution status, last execution time, and success/settle counts\n * - State can be accessed via `asyncThrottler.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `asyncThrottler.state`\n *\n * @example\n * ```ts\n * const throttler = new AsyncThrottler(async (value: string) => {\n *   const result = await saveToAPI(value);\n *   return result; // Return value is preserved\n * }, {\n *   wait: 1000,\n *   onError: (error) => {\n *     console.error('API call failed:', error);\n *   }\n * });\n *\n * // Will only execute once per second no matter how often called\n * // Returns the API response directly\n * const result = await throttler.maybeExecute(inputElement.value);\n * ```\n */\nexport class AsyncThrottler<TFn extends AnyAsyncFunction> {\n  readonly store: Store<Readonly<AsyncThrottlerState<TFn>>> = new Store<\n    AsyncThrottlerState<TFn>\n  >(getDefaultAsyncThrottlerState<TFn>())\n  key: string\n  options: AsyncThrottlerOptions<TFn>\n  #abortController: AbortController | null = null\n  #timeoutId: NodeJS.Timeout | null = null\n  #resolvePreviousPromise:\n    | ((value?: ReturnType<TFn> | undefined) => void)\n    | null = null\n\n  constructor(\n    public fn: TFn,\n    initialOptions: AsyncThrottlerOptions<TFn>,\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n      throwOnError: initialOptions.throwOnError ?? !initialOptions.onError,\n    }\n    this.#setState(this.options.initialState ?? {})\n    pacerEventClient.on('d-AsyncThrottler', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state as AsyncThrottlerState<TFn>)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the async throttler options\n   */\n  setOptions = (newOptions: Partial<AsyncThrottlerOptions<TFn>>): void => {\n    this.options = { ...this.options, ...newOptions }\n\n    // End the pending state if the throttler is disabled\n    if (!this.#getEnabled()) {\n      this.cancel()\n    }\n  }\n\n  #setState = (newState: Partial<AsyncThrottlerState<TFn>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n      const { isPending, isExecuting, settleCount } = combinedState\n      return {\n        ...combinedState,\n        status: !this.#getEnabled()\n          ? 'disabled'\n          : isPending\n            ? 'pending'\n            : isExecuting\n              ? 'executing'\n              : settleCount > 0\n                ? 'settled'\n                : 'idle',\n      }\n    })\n    emitChange('AsyncThrottler', this)\n  }\n\n  /**\n   * Returns the current enabled state of the async throttler\n   */\n  #getEnabled = (): boolean => {\n    return !!parseFunctionOrValue(this.options.enabled, this)\n  }\n\n  /**\n   * Returns the current wait time in milliseconds\n   */\n  #getWait = (): number => {\n    return parseFunctionOrValue(this.options.wait, this)\n  }\n\n  /**\n   * Attempts to execute the throttled function. The execution behavior depends on the throttler options:\n   *\n   * - If enough time has passed since the last execution (>= wait period):\n   *   - With leading=true: Executes immediately\n   *   - With leading=false: Waits for the next trailing execution\n   *\n   * - If within the wait period:\n   *   - With trailing=true: Schedules execution for end of wait period\n   *   - With trailing=false: Drops the execution\n   *\n   * @example\n   * ```ts\n   * const throttled = new AsyncThrottler(fn, { wait: 1000 });\n   *\n   * // First call executes immediately\n   * await throttled.maybeExecute('a', 'b');\n   *\n   * // Call during wait period - gets throttled\n   * await throttled.maybeExecute('c', 'd');\n   * ```\n   */\n  maybeExecute = async (\n    ...args: Parameters<TFn>\n  ): Promise<ReturnType<TFn> | undefined> => {\n    if (!this.#getEnabled()) return undefined\n    const now = Date.now()\n    const timeSinceLastExecution = now - this.store.state.lastExecutionTime\n    const wait = this.#getWait()\n    // Store the most recent arguments for potential trailing execution\n    this.#setState({\n      lastArgs: args,\n      maybeExecuteCount: this.store.state.maybeExecuteCount + 1,\n    })\n\n    this.#resolvePreviousPromiseInternal()\n\n    // Handle leading execution\n    if (this.options.leading && timeSinceLastExecution >= wait) {\n      await this.#execute(...args)\n      return this.store.state.lastResult\n    } else {\n      return new Promise((resolve, reject) => {\n        this.#resolvePreviousPromise = resolve\n        // Clear any existing timeout to ensure we use the latest arguments\n        this.#clearTimeout()\n\n        // Set up trailing execution if enabled\n        if (this.options.trailing) {\n          const _timeSinceLastExecution = this.store.state.lastExecutionTime\n            ? now - this.store.state.lastExecutionTime\n            : 0\n          const timeoutDuration = wait - _timeSinceLastExecution\n          this.#setState({ isPending: true })\n          this.#timeoutId = setTimeout(async () => {\n            if (this.store.state.lastArgs !== undefined) {\n              try {\n                await this.#execute(...this.store.state.lastArgs) // EXECUTE!\n              } catch (error) {\n                reject(error)\n              }\n            }\n            this.#resolvePreviousPromise = null\n            resolve(this.store.state.lastResult)\n          }, timeoutDuration)\n        }\n      })\n    }\n  }\n\n  #execute = async (\n    ...args: Parameters<TFn>\n  ): Promise<ReturnType<TFn> | undefined> => {\n    if (!this.#getEnabled() || this.store.state.isExecuting) return undefined\n    this.#abortController = new AbortController()\n    try {\n      this.#setState({ isExecuting: true })\n      const result = await this.fn(...args) // EXECUTE!\n      this.#setState({\n        lastResult: result,\n        successCount: this.store.state.successCount + 1,\n      })\n      this.options.onSuccess?.(result, args, this)\n    } catch (error) {\n      this.#setState({\n        errorCount: this.store.state.errorCount + 1,\n      })\n      this.options.onError?.(error, args, this)\n      if (this.options.throwOnError) {\n        throw error\n      }\n    } finally {\n      const lastExecutionTime = Date.now()\n      const nextExecutionTime = lastExecutionTime + this.#getWait()\n      this.#setState({\n        isExecuting: false,\n        isPending: false,\n        settleCount: this.store.state.settleCount + 1,\n        lastExecutionTime,\n        nextExecutionTime,\n      })\n      this.#abortController = null\n      this.options.onSettled?.(args, this)\n      setTimeout(() => {\n        if (!this.store.state.isPending) {\n          this.#setState({ nextExecutionTime: undefined })\n        }\n      }, this.#getWait())\n    }\n    return this.store.state.lastResult\n  }\n\n  /**\n   * Processes the current pending execution immediately\n   */\n  flush = async (): Promise<ReturnType<TFn> | undefined> => {\n    if (this.store.state.isPending && this.store.state.lastArgs) {\n      this.#abortExecution() // abort any current execution\n      this.#clearTimeout() // clear any existing timeout\n      const result = await this.#execute(...this.store.state.lastArgs)\n\n      // Resolve any pending promise from maybeExecute\n      this.#resolvePreviousPromiseInternal()\n\n      return result\n    }\n    return undefined\n  }\n\n  #resolvePreviousPromiseInternal = (): void => {\n    if (this.#resolvePreviousPromise) {\n      this.#resolvePreviousPromise(this.store.state.lastResult)\n      this.#resolvePreviousPromise = null\n    }\n  }\n\n  #clearTimeout = (): void => {\n    if (this.#timeoutId) {\n      clearTimeout(this.#timeoutId)\n      this.#timeoutId = null\n    }\n  }\n\n  #cancelPendingExecution = (): void => {\n    this.#clearTimeout()\n    if (this.#resolvePreviousPromise) {\n      this.#resolvePreviousPromiseInternal()\n      this.#resolvePreviousPromise = null\n    }\n    this.#setState({\n      isPending: false,\n      isExecuting: false,\n      lastArgs: undefined,\n    })\n  }\n\n  #abortExecution = (): void => {\n    if (this.#abortController) {\n      this.#abortController.abort()\n      this.#abortController = null\n    }\n  }\n\n  /**\n   * Cancels any pending execution or aborts any execution in progress\n   */\n  cancel = (): void => {\n    this.#cancelPendingExecution()\n    this.#abortExecution()\n  }\n\n  /**\n   * Resets the debouncer state to its default values\n   */\n  reset = (): void => {\n    this.#setState(getDefaultAsyncThrottlerState<TFn>())\n  }\n}\n\n/**\n * Creates an async throttled function that limits how often the function can execute.\n * The throttled function will execute at most once per wait period, even if called multiple times.\n * If called while executing, it will wait until execution completes before scheduling the next call.\n *\n * Unlike the non-async Throttler, this async version supports returning values from the throttled function,\n * making it ideal for API calls and other async operations where you want the result of the `maybeExecute` call\n * instead of setting the result on a state variable from within the throttled function.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and throttler instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together - the handler will be called before any error is thrown\n * - The error state can be checked using the underlying AsyncThrottler instance\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the async throttler\n * - Use `onSuccess` callback to react to successful function execution and implement custom logic\n * - Use `onError` callback to react to function execution errors and implement custom error handling\n * - Use `onSettled` callback to react to function execution completion (success or error) and implement custom logic\n * - The state includes error count, execution status, last execution time, and success/settle counts\n * - State can be accessed via the underlying AsyncThrottler instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * @example\n * ```ts\n * const throttled = asyncThrottle(async (value: string) => {\n *   const result = await saveToAPI(value);\n *   return result; // Return value is preserved\n * }, {\n *   wait: 1000,\n *   onError: (error) => {\n *     console.error('API call failed:', error);\n *   }\n * });\n *\n * // This will execute at most once per second\n * // Returns the API response directly\n * const result = await throttled(inputElement.value);\n * ```\n */\nexport function asyncThrottle<TFn extends AnyAsyncFunction>(\n  fn: TFn,\n  initialOptions: AsyncThrottlerOptions<TFn>,\n) {\n  const asyncThrottler = new AsyncThrottler(fn, initialOptions)\n  return asyncThrottler.maybeExecute\n}\n"],"names":[],"mappings":"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"}