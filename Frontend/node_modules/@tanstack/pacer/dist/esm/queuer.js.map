{"version":3,"file":"queuer.js","sources":["../../src/queuer.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\n\nexport interface QueuerState<TValue> {\n  /**\n   * Number of times addItem has been called (for reduction calculations)\n   */\n  addItemCount: number\n  /**\n   * Number of items that have been processed by the queuer\n   */\n  executionCount: number\n  /**\n   * Number of items that have been removed from the queue due to expiration\n   */\n  expirationCount: number\n  /**\n   * Whether the queuer has no items to process (items array is empty)\n   */\n  isEmpty: boolean\n  /**\n   * Whether the queuer has reached its maximum capacity\n   */\n  isFull: boolean\n  /**\n   * Whether the queuer is not currently processing any items\n   */\n  isIdle: boolean\n  /**\n   * Whether the queuer is active and will process items automatically\n   */\n  isRunning: boolean\n  /**\n   * Array of items currently waiting to be processed\n   */\n  items: Array<TValue>\n  /**\n   * Timestamps when items were added to the queue for expiration tracking\n   */\n  itemTimestamps: Array<number>\n  /**\n   * Whether the queuer has a pending timeout for processing the next item\n   */\n  pendingTick: boolean\n  /**\n   * Number of items that have been rejected from being added to the queue\n   */\n  rejectionCount: number\n  /**\n   * Number of items currently in the queue\n   */\n  size: number\n  /**\n   * Current processing status - 'idle' when not processing, 'running' when active, 'stopped' when paused\n   */\n  status: 'idle' | 'running' | 'stopped'\n}\n\nfunction getDefaultQueuerState<TValue>(): QueuerState<TValue> {\n  return {\n    executionCount: 0,\n    expirationCount: 0,\n    isEmpty: true,\n    isFull: false,\n    isIdle: true,\n    isRunning: true,\n    itemTimestamps: [],\n    items: [],\n    pendingTick: false,\n    rejectionCount: 0,\n    size: 0,\n    status: 'idle',\n    addItemCount: 0,\n  }\n}\n\n/**\n * Options for configuring a Queuer instance.\n *\n * These options control queue behavior, item expiration, callbacks, and more.\n */\nexport interface QueuerOptions<TValue> {\n  /**\n   * Default position to add items to the queuer\n   * @default 'back'\n   */\n  addItemsTo?: QueuePosition\n  /**\n   * Maximum time in milliseconds that an item can stay in the queue\n   * If not provided, items will never expire\n   */\n  expirationDuration?: number\n  /**\n   * Function to determine if an item has expired\n   * If provided, this overrides the expirationDuration behavior\n   */\n  getIsExpired?: (item: TValue, addedAt: number) => boolean\n  /**\n   * Default position to get items from during processing\n   * @default 'front'\n   */\n  getItemsFrom?: QueuePosition\n  /**\n   * Function to determine priority of items in the queuer\n   * Higher priority items will be processed first\n   */\n  getPriority?: (item: TValue) => number\n  /**\n   * Initial items to populate the queuer with\n   */\n  initialItems?: Array<TValue>\n  /**\n   * Initial state for the queuer\n   */\n  initialState?: Partial<QueuerState<TValue>>\n  /**\n   * Optional key to identify this queuer instance.\n   * If provided, the queuer will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Maximum number of items allowed in the queuer\n   */\n  maxSize?: number\n  /**\n   * Callback fired whenever an item is removed from the queuer\n   */\n  onExecute?: (item: TValue, queuer: Queuer<TValue>) => void\n  /**\n   * Callback fired whenever an item expires in the queuer\n   */\n  onExpire?: (item: TValue, queuer: Queuer<TValue>) => void\n  /**\n   * Callback fired whenever an item is added or removed from the queuer\n   */\n  onItemsChange?: (queuer: Queuer<TValue>) => void\n  /**\n   * Callback fired whenever an item is rejected from being added to the queuer\n   */\n  onReject?: (item: TValue, queuer: Queuer<TValue>) => void\n  /**\n   * Whether the queuer should start processing tasks immediately\n   */\n  started?: boolean\n  /**\n   * Time in milliseconds to wait between processing items.\n   * Can be a number or a function that returns a number.\n   * @default 0\n   */\n  wait?: number | ((queuer: Queuer<TValue>) => number)\n}\n\nconst defaultOptions: Omit<\n  Required<QueuerOptions<any>>,\n  | 'initialState'\n  | 'onExecute'\n  | 'onIsRunningChange'\n  | 'onItemsChange'\n  | 'onReject'\n  | 'onExpire'\n  | 'key'\n> = {\n  addItemsTo: 'back',\n  getItemsFrom: 'front',\n  getPriority: (item) => item?.priority ?? 0,\n  getIsExpired: () => false,\n  expirationDuration: Infinity,\n  initialItems: [],\n  maxSize: Infinity,\n  started: true,\n  wait: 0,\n}\n\n/**\n * Position type for addItem and getNextItem operations.\n *\n * - 'front': Operate on the front of the queue (FIFO)\n * - 'back': Operate on the back of the queue (LIFO)\n */\nexport type QueuePosition = 'front' | 'back'\n\n/**\n * A flexible queue that processes items with configurable wait times, expiration, and priority.\n *\n * Features:\n * - Automatic or manual processing of items\n * - FIFO (First In First Out), LIFO (Last In First Out), or double-ended queue behavior\n * - Priority-based ordering when getPriority is provided\n * - Item expiration and removal of stale items\n * - Callbacks for queue state changes, execution, rejection, and expiration\n *\n * Running behavior:\n * - `start()`: Begins automatically processing items in the queue (defaults to isRunning)\n * - `stop()`: Pauses processing but maintains queue state\n * - `wait`: Configurable delay between processing items\n * - `onItemsChange`/`onExecute`: Callbacks for monitoring queue state\n *\n * Manual processing is also supported when automatic processing is disabled:\n * - `execute()`: Processes the next item using the provided function\n * - `getNextItem()`: Removes and returns the next item without processing\n *\n * Queue behavior defaults to FIFO:\n * - `addItem(item)`: Adds to the back of the queue\n * - Items processed from the front of the queue\n *\n * Priority queue:\n * - Provide a `getPriority` function; higher values are processed first\n *\n * Stack (LIFO):\n * - `addItem(item, 'back')`: Adds to the back\n * - `getNextItem('back')`: Removes from the back\n *\n * Double-ended queue:\n * - `addItem(item, position)`: Adds to specified position ('front'/'back')\n * - `getNextItem(position)`: Removes from specified position\n *\n * Item expiration:\n * - `expirationDuration`: Maximum time items can stay in the queue\n * - `getIsExpired`: Function to override default expiration\n * - `onExpire`: Callback for expired items\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the queuer\n * - Use `onExecute` callback to react to item execution and implement custom logic\n * - Use `onItemsChange` callback to react to items being added or removed from the queue\n * - Use `onExpire` callback to react to items expiring and implement custom logic\n * - Use `onReject` callback to react to items being rejected when the queue is full\n * - The state includes execution count, expiration count, rejection count, and isRunning status\n * - State can be accessed via `queuer.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `queuer.state`\n *\n * Example usage:\n * ```ts\n * // Auto-processing queue with wait time\n * const autoQueue = new Queuer<number>((n) => console.log(n), {\n *   started: true, // Begin processing immediately\n *   wait: 1000, // Wait 1s between items\n *   onExecute: (item, queuer) => console.log(`Processed ${item}`)\n * });\n * autoQueue.addItem(1); // Will process after 1s\n * autoQueue.addItem(2); // Will process 1s after first item\n *\n * // Manual processing queue\n * const manualQueue = new Queuer<number>((n) => console.log(n), {\n *   started: false\n * });\n * manualQueue.addItem(1); // [1]\n * manualQueue.addItem(2); // [1, 2]\n * manualQueue.execute(); // logs 1, queue is [2]\n * manualQueue.getNextItem(); // returns 2, queue is empty\n * ```\n */\nexport class Queuer<TValue> {\n  readonly store: Store<Readonly<QueuerState<TValue>>> = new Store(\n    getDefaultQueuerState<TValue>(),\n  )\n  key: string\n  options: QueuerOptions<TValue>\n  #timeoutId: NodeJS.Timeout | null = null\n\n  constructor(\n    public fn: (item: TValue) => void,\n    initialOptions: QueuerOptions<TValue> = {},\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n    }\n    const isInitiallyRunning =\n      this.options.initialState?.isRunning ?? this.options.started ?? true\n    this.#setState({\n      ...this.options.initialState,\n      isRunning: isInitiallyRunning,\n    })\n\n    if (this.options.initialState?.items) {\n      if (this.store.state.isRunning) {\n        this.#tick()\n      }\n    } else {\n      for (let i = 0; i < (this.options.initialItems?.length ?? 0); i++) {\n        const item = this.options.initialItems![i]!\n        const isLast = i === (this.options.initialItems?.length ?? 0) - 1\n        this.addItem(item, this.options.addItemsTo ?? 'back', isLast)\n      }\n    }\n    pacerEventClient.on('d-Queuer', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the queuer options. New options are merged with existing options.\n   */\n  setOptions = (newOptions: Partial<QueuerOptions<TValue>>): void => {\n    this.options = { ...this.options, ...newOptions }\n  }\n\n  #setState = (newState: Partial<QueuerState<TValue>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n\n      const { items, isRunning } = combinedState\n\n      const size = items.length\n      const isFull = size >= (this.options.maxSize ?? Infinity)\n      const isEmpty = size === 0\n      const isIdle = isRunning && isEmpty\n\n      const status = isIdle ? 'idle' : isRunning ? 'running' : 'stopped'\n\n      return {\n        ...combinedState,\n        isEmpty,\n        isFull,\n        isIdle,\n        size,\n        status,\n      }\n    })\n    emitChange('Queuer', this)\n  }\n\n  /**\n   * Returns the current wait time (in milliseconds) between processing items.\n   * If a function is provided, it is called with the queuer instance.\n   */\n  #getWait = (): number => {\n    return parseFunctionOrValue(this.options.wait ?? 0, this)\n  }\n\n  /**\n   * Processes items in the queue up to the wait interval. Internal use only.\n   */\n  #tick = () => {\n    if (!this.store.state.isRunning) {\n      this.#setState({ pendingTick: false })\n      return\n    }\n\n    this.#setState({ pendingTick: true })\n\n    // Check for expired items\n    this.#checkExpiredItems()\n\n    while (this.store.state.items.length > 0) {\n      const nextItem = this.execute(this.options.getItemsFrom ?? 'front')\n      if (nextItem === undefined) {\n        break\n      }\n\n      const wait = this.#getWait()\n      if (wait > 0) {\n        // Use setTimeout to wait before processing next item\n        this.#timeoutId = setTimeout(() => this.#tick(), wait)\n        return\n      }\n\n      this.#tick()\n    }\n    this.#setState({ pendingTick: false })\n  }\n\n  /**\n   * Adds an item to the queue. If the queue is full, the item is rejected and onReject is called.\n   * Items can be inserted based on priority or at the front/back depending on configuration.\n   *\n   * Returns true if the item was added, false if the queue is full.\n   *\n   * Example usage:\n   * ```ts\n   * queuer.addItem('task');\n   * queuer.addItem('task2', 'front');\n   * ```\n   */\n  addItem = (\n    item: TValue,\n    position: QueuePosition = this.options.addItemsTo ?? 'back',\n    runOnItemsChange: boolean = true,\n  ): boolean => {\n    this.#setState({\n      addItemCount: this.store.state.addItemCount + 1,\n    })\n\n    if (this.store.state.items.length >= (this.options.maxSize ?? Infinity)) {\n      this.#setState({\n        rejectionCount: this.store.state.rejectionCount + 1,\n      })\n      this.options.onReject?.(item, this)\n      return false\n    }\n\n    // Get priority either from the function or from getPriority option\n    const priority =\n      this.options.getPriority !== defaultOptions.getPriority\n        ? this.options.getPriority!(item)\n        : (item as any).priority\n\n    const items = this.store.state.items\n    const itemTimestamps = this.store.state.itemTimestamps\n\n    if (priority !== undefined) {\n      // Insert based on priority - higher priority items go to front\n      const insertIndex = items.findIndex((existing) => {\n        const existingPriority: number =\n          this.options.getPriority !== defaultOptions.getPriority\n            ? this.options.getPriority!(existing)\n            : (existing as any).priority\n        return existingPriority < priority\n      })\n\n      if (insertIndex === -1) {\n        items.push(item)\n        itemTimestamps.push(Date.now())\n      } else {\n        items.splice(insertIndex, 0, item)\n        itemTimestamps.splice(insertIndex, 0, Date.now())\n      }\n    } else {\n      if (position === 'front') {\n        // Default FIFO/LIFO behavior\n        items.unshift(item)\n        itemTimestamps.unshift(Date.now())\n      } else {\n        // LIFO\n        items.push(item)\n        itemTimestamps.push(Date.now())\n      }\n    }\n\n    this.#setState({\n      items,\n      itemTimestamps,\n    })\n\n    if (runOnItemsChange) {\n      this.options.onItemsChange?.(this)\n    }\n\n    if (this.store.state.isRunning && !this.store.state.pendingTick) {\n      this.#setState({ pendingTick: true })\n      this.#tick()\n    }\n\n    return true\n  }\n\n  /**\n   * Removes and returns the next item from the queue without executing the function.\n   * Use for manual queue management. Normally, use execute() to process items.\n   *\n   * Example usage:\n   * ```ts\n   * // FIFO\n   * queuer.getNextItem();\n   * // LIFO\n   * queuer.getNextItem('back');\n   * ```\n   */\n  getNextItem = (\n    position: QueuePosition = this.options.getItemsFrom ?? 'front',\n  ): TValue | undefined => {\n    const { items, itemTimestamps } = this.store.state\n    let item: TValue | undefined\n\n    // When priority function is provided, always get from front (highest priority)\n    // Priority takes precedence over FIFO/LIFO behavior\n    if (\n      this.options.getPriority !== defaultOptions.getPriority ||\n      position === 'front'\n    ) {\n      item = items[0]\n      if (item !== undefined) {\n        this.#setState({\n          items: items.slice(1),\n          itemTimestamps: itemTimestamps.slice(1),\n        })\n      }\n    } else {\n      item = items[items.length - 1]\n      if (item !== undefined) {\n        this.#setState({\n          items: items.slice(0, -1),\n          itemTimestamps: itemTimestamps.slice(0, -1),\n        })\n      }\n    }\n\n    if (item !== undefined) {\n      this.options.onItemsChange?.(this)\n    }\n\n    return item\n  }\n\n  #getAllItems = (): Array<TValue> => {\n    const items = this.peekAllItems()\n    this.clear()\n    return items\n  }\n\n  /**\n   * Removes and returns the next item from the queue and processes it using the provided function.\n   *\n   * Example usage:\n   * ```ts\n   * queuer.execute();\n   * // LIFO\n   * queuer.execute('back');\n   * ```\n   */\n  execute = (position?: QueuePosition): TValue | undefined => {\n    const item = this.getNextItem(position)\n    if (item !== undefined) {\n      this.fn(item)\n      this.#setState({\n        executionCount: this.store.state.executionCount + 1,\n      })\n      this.options.onExecute?.(item, this)\n    }\n    return item\n  }\n\n  /**\n   * Processes a specified number of items to execute immediately with no wait time\n   * If no numberOfItems is provided, all items will be processed\n   */\n  flush = (\n    numberOfItems: number = this.store.state.items.length,\n    position?: QueuePosition,\n  ): void => {\n    this.#clearTimeout() // clear any pending timeout\n    for (let i = 0; i < numberOfItems; i++) {\n      this.execute(position)\n    }\n    this.#tick()\n  }\n\n  /**\n   * Processes all items in the queue as a batch using the provided function as an argument\n   * The queue is cleared after processing\n   */\n  flushAsBatch = (batchFunction: (items: Array<TValue>) => void): void => {\n    const items = this.#getAllItems()\n    this.clear()\n    batchFunction(items)\n  }\n\n  /**\n   * Checks for expired items in the queue and removes them. Calls onExpire for each expired item.\n   * Internal use only.\n   */\n  #checkExpiredItems = (): void => {\n    if (\n      (this.options.expirationDuration ?? Infinity) === Infinity &&\n      this.options.getIsExpired === defaultOptions.getIsExpired\n    ) {\n      return\n    }\n\n    const now = Date.now()\n    const expiredIndices: Array<number> = []\n\n    // Find indices of expired items\n    for (let i = 0; i < this.store.state.items.length; i++) {\n      const timestamp = this.store.state.itemTimestamps[i]\n      if (timestamp === undefined) continue\n\n      const item = this.store.state.items[i]\n      if (item === undefined) continue\n\n      const isExpired =\n        this.options.getIsExpired !== defaultOptions.getIsExpired\n          ? this.options.getIsExpired!(item, timestamp)\n          : now - timestamp > (this.options.expirationDuration ?? Infinity)\n\n      if (isExpired) {\n        expiredIndices.push(i)\n      }\n    }\n\n    // Remove expired items from back to front to maintain indices\n    for (let i = expiredIndices.length - 1; i >= 0; i--) {\n      const index = expiredIndices[i]\n      if (index === undefined) continue\n\n      const expiredItem = this.store.state.items[index]\n      if (expiredItem === undefined) continue\n\n      const newItems = [...this.store.state.items]\n      const newTimestamps = [...this.store.state.itemTimestamps]\n      newItems.splice(index, 1)\n      newTimestamps.splice(index, 1)\n      this.#setState({\n        items: newItems,\n        itemTimestamps: newTimestamps,\n        expirationCount: this.store.state.expirationCount + 1,\n      })\n      this.options.onExpire?.(expiredItem, this)\n    }\n\n    if (expiredIndices.length > 0) {\n      this.options.onItemsChange?.(this)\n    }\n  }\n\n  /**\n   * Returns the next item in the queue without removing it.\n   *\n   * Example usage:\n   * ```ts\n   * queuer.peekNextItem(); // front\n   * queuer.peekNextItem('back'); // back\n   * ```\n   */\n  peekNextItem = (position: QueuePosition = 'front'): TValue | undefined => {\n    if (position === 'front') {\n      return this.store.state.items[0]\n    }\n    return this.store.state.items[this.store.state.items.length - 1]\n  }\n\n  /**\n   * Returns a copy of all items in the queue.\n   */\n  peekAllItems = (): Array<TValue> => {\n    return [...this.store.state.items]\n  }\n\n  /**\n   * Starts processing items in the queue. If already isRunning, does nothing.\n   */\n  start = () => {\n    this.#setState({ isRunning: true })\n    if (!this.store.state.pendingTick && this.store.state.items.length > 0) {\n      this.#tick()\n    }\n  }\n\n  /**\n   * Stops processing items in the queue. Does not clear the queue.\n   */\n  stop = () => {\n    this.#clearTimeout()\n    this.#setState({ isRunning: false, pendingTick: false })\n  }\n\n  #clearTimeout = (): void => {\n    if (this.#timeoutId) {\n      clearTimeout(this.#timeoutId)\n      this.#timeoutId = null\n    }\n  }\n\n  /**\n   * Removes all pending items from the queue. Does not affect items being processed.\n   */\n  clear = (): void => {\n    this.#setState({ items: [], itemTimestamps: [] })\n    this.options.onItemsChange?.(this)\n  }\n\n  /**\n   * Resets the queuer state to its default values\n   */\n  reset = (): void => {\n    this.#setState(getDefaultQueuerState<TValue>())\n    this.options.onItemsChange?.(this)\n  }\n}\n\n/**\n * Creates a queue that processes items immediately upon addition.\n * Items are processed sequentially in FIFO order by default.\n *\n * This is a simplified wrapper around the Queuer class that only exposes the\n * `addItem` method. The queue is always isRunning and will process items as they are added.\n * For more control over queue processing, use the Queuer class directly.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the queuer\n * - Use `onExecute` callback to react to item execution and implement custom logic\n * - Use `onItemsChange` callback to react to items being added or removed from the queue\n * - Use `onExpire` callback to react to items expiring and implement custom logic\n * - Use `onReject` callback to react to items being rejected when the queue is full\n * - The state includes execution count, expiration count, rejection count, and isRunning status\n * - State can be accessed via the underlying Queuer instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * Example usage:\n * ```ts\n * // Basic sequential processing\n * const processItems = queue<number>((n) => console.log(n), {\n *   wait: 1000,\n *   onItemsChange: (queuer) => console.log(queuer.peekAllItems())\n * });\n * processItems(1); // Logs: 1\n * processItems(2); // Logs: 2 after 1 completes\n *\n * // Priority queue\n * const processPriority = queue<number>((n) => console.log(n), {\n *   getPriority: n => n // Higher numbers processed first\n * });\n * processPriority(1);\n * processPriority(3); // Processed before 1\n * ```\n */\nexport function queue<TValue>(\n  fn: (item: TValue) => void,\n  initialOptions: QueuerOptions<TValue>,\n) {\n  const queuer = new Queuer<TValue>(fn, initialOptions)\n  return queuer.addItem\n}\n"],"names":[],"mappings":"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"}