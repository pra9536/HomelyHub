{"version":3,"file":"rate-limiter.js","sources":["../../src/rate-limiter.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { AnyFunction } from './types'\n\nexport interface RateLimiterState {\n  /**\n   * Number of function executions that have been completed\n   */\n  executionCount: number\n  /**\n   * Array of timestamps when executions occurred for rate limiting calculations\n   */\n  executionTimes: Array<number>\n  /**\n   * Whether the rate limiter has exceeded the limit\n   */\n  isExceeded: boolean\n  /**\n   * Number of times maybeExecute has been called (for reduction calculations)\n   */\n  maybeExecuteCount: number\n  /**\n   * Number of function executions that have been rejected due to rate limiting\n   */\n  rejectionCount: number\n  /**\n   * Current execution status - 'disabled' when not active, 'executing' when executing, 'idle' when not executing, 'exceeded' when rate limit is exceeded\n   */\n  status: 'disabled' | 'exceeded' | 'idle'\n}\n\nfunction getDefaultRateLimiterState(): RateLimiterState {\n  return {\n    executionCount: 0,\n    executionTimes: [],\n    isExceeded: false,\n    rejectionCount: 0,\n    status: 'idle',\n    maybeExecuteCount: 0,\n  }\n}\n\n/**\n * Options for configuring a rate-limited function\n */\nexport interface RateLimiterOptions<TFn extends AnyFunction> {\n  /**\n   * Whether the rate limiter is enabled. When disabled, maybeExecute will not trigger any executions.\n   * Defaults to true.\n   */\n  enabled?: boolean | ((rateLimiter: RateLimiter<TFn>) => boolean)\n  /**\n   * Initial state for the rate limiter\n   */\n  initialState?: Partial<RateLimiterState>\n  /**\n   * Optional key to identify this rate limiter instance.\n   * If provided, the rate limiter will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Maximum number of executions allowed within the time window.\n   * Can be a number or a callback function that receives the rate limiter instance and returns a number.\n   */\n  limit: number | ((rateLimiter: RateLimiter<TFn>) => number)\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, rateLimiter: RateLimiter<TFn>) => void\n  /**\n   * Optional callback function that is called when an execution is rejected due to rate limiting\n   */\n  onReject?: (rateLimiter: RateLimiter<TFn>) => void\n  /**\n   * Time window in milliseconds within which the limit applies.\n   * Can be a number or a callback function that receives the rate limiter instance and returns a number.\n   */\n  window: number | ((rateLimiter: RateLimiter<TFn>) => number)\n  /**\n   * Type of window to use for rate limiting\n   * - 'fixed': Uses a fixed window that resets after the window period\n   * - 'sliding': Uses a sliding window that allows executions as old ones expire\n   * Defaults to 'fixed'\n   */\n  windowType?: 'fixed' | 'sliding'\n}\n\nconst defaultOptions: Omit<\n  Required<RateLimiterOptions<any>>,\n  'initialState' | 'onExecute' | 'onReject' | 'key'\n> = {\n  enabled: true,\n  limit: 1,\n  window: 0,\n  windowType: 'fixed',\n}\n\n/**\n * A class that creates a rate-limited function.\n *\n * Rate limiting is a simple approach that allows a function to execute up to a limit within a time window,\n * then blocks all subsequent calls until the window passes. This can lead to \"bursty\" behavior where\n * all executions happen immediately, followed by a complete block.\n *\n * The rate limiter supports two types of windows:\n * - 'fixed': A strict window that resets after the window period. All executions within the window count\n *   towards the limit, and the window resets completely after the period.\n * - 'sliding': A rolling window that allows executions as old ones expire. This provides a more\n *   consistent rate of execution over time.\n *\n * For smoother execution patterns, consider using:\n * - Throttling: Ensures consistent spacing between executions (e.g. max once per 200ms)\n * - Debouncing: Waits for a pause in calls before executing (e.g. after 500ms of no calls)\n *\n * Rate limiting is best used for hard API limits or resource constraints. For UI updates or\n * smoothing out frequent events, throttling or debouncing usually provide better user experience.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the rate limiter\n * - Use `onExecute` callback to react to function execution and implement custom logic\n * - Use `onReject` callback to react to executions being rejected when rate limit is exceeded\n * - The state includes execution count, execution times, and rejection count\n * - State can be accessed via `rateLimiter.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `rateLimiter.state`\n *\n * @example\n * ```ts\n * const rateLimiter = new RateLimiter(\n *   (id: string) => api.getData(id),\n *   {\n *     limit: 5,\n *     window: 1000,\n *     windowType: 'sliding',\n *   }\n * );\n *\n * // Will execute immediately until limit reached, then block\n * rateLimiter.maybeExecute('123');\n * ```\n */\nexport class RateLimiter<TFn extends AnyFunction> {\n  readonly store: Store<Readonly<RateLimiterState>> =\n    new Store<RateLimiterState>(getDefaultRateLimiterState())\n  key: string\n  options: RateLimiterOptions<TFn>\n  #timeoutIds: Set<NodeJS.Timeout> = new Set()\n\n  constructor(\n    public fn: TFn,\n    initialOptions: RateLimiterOptions<TFn>,\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n    }\n    this.#setState(this.options.initialState ?? {})\n    for (const executionTime of this.#getExecutionTimesInWindow()) {\n      this.#setCleanupTimeout(executionTime)\n    }\n\n    pacerEventClient.on('d-RateLimiter', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the rate limiter options\n   */\n  setOptions = (newOptions: Partial<RateLimiterOptions<TFn>>): void => {\n    this.options = { ...this.options, ...newOptions }\n  }\n\n  #setState = (newState: Partial<RateLimiterState>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n      const isExceeded = combinedState.executionTimes.length >= this.#getLimit()\n      const status = !this.#getEnabled()\n        ? 'disabled'\n        : isExceeded\n          ? 'exceeded'\n          : 'idle'\n      return {\n        ...combinedState,\n        isExceeded,\n        status,\n      }\n    })\n    emitChange('RateLimiter', this)\n  }\n\n  /**\n   * Returns the current enabled state of the rate limiter\n   */\n  #getEnabled = (): boolean => {\n    return !!parseFunctionOrValue(this.options.enabled, this)\n  }\n\n  /**\n   * Returns the current limit of executions allowed within the time window\n   */\n  #getLimit = (): number => {\n    return parseFunctionOrValue(this.options.limit, this)\n  }\n\n  /**\n   * Returns the current time window in milliseconds\n   */\n  #getWindow = (): number => {\n    return parseFunctionOrValue(this.options.window, this)\n  }\n\n  /**\n   * Attempts to execute the rate-limited function if within the configured limits.\n   * Will reject execution if the number of calls in the current window exceeds the limit.\n   *\n   * @example\n   * ```ts\n   * const rateLimiter = new RateLimiter(fn, { limit: 5, window: 1000 });\n   *\n   * // First 5 calls will return true\n   * rateLimiter.maybeExecute('arg1', 'arg2'); // true\n   *\n   * // Additional calls within the window will return false\n   * rateLimiter.maybeExecute('arg1', 'arg2'); // false\n   * ```\n   */\n  maybeExecute = (...args: Parameters<TFn>): boolean => {\n    this.#setState({\n      maybeExecuteCount: this.store.state.maybeExecuteCount + 1,\n    })\n\n    this.#cleanupOldExecutions()\n\n    const relevantExecutionTimes = this.#getExecutionTimesInWindow()\n\n    if (relevantExecutionTimes.length < this.#getLimit()) {\n      this.#execute(...args)\n      return true\n    }\n\n    this.#setState({\n      rejectionCount: this.store.state.rejectionCount + 1,\n    })\n    this.options.onReject?.(this)\n    return false\n  }\n\n  #execute = (...args: Parameters<TFn>): void => {\n    if (!this.#getEnabled()) return\n    const now = Date.now()\n    this.fn(...args) // EXECUTE!\n    this.store.state.executionTimes.push(now) // mutate state directly for performance\n\n    this.#setCleanupTimeout(now)\n\n    this.#setState({\n      executionCount: this.store.state.executionCount + 1,\n    })\n    this.options.onExecute?.(args, this)\n  }\n\n  #getExecutionTimesInWindow = (): Array<number> => {\n    if (this.options.windowType === 'sliding') {\n      // For sliding window, return all executions within the current window\n      return this.store.state.executionTimes.filter(\n        (time) => time > Date.now() - this.#getWindow(),\n      )\n    } else {\n      // For fixed window, return all executions in the current window\n      // The window starts from the oldest execution time\n      if (this.store.state.executionTimes.length === 0) {\n        return []\n      }\n      const oldestExecution = Math.min(...this.store.state.executionTimes)\n      const windowStart = oldestExecution\n      const windowEnd = windowStart + this.#getWindow()\n      const now = Date.now()\n\n      // If the window has expired, return empty array\n      if (now > windowEnd) {\n        return []\n      }\n\n      // Otherwise, return all executions in the current window\n      return this.store.state.executionTimes.filter(\n        (time) => time >= windowStart && time <= windowEnd,\n      )\n    }\n  }\n\n  #setCleanupTimeout = (executionTime: number): void => {\n    if (\n      this.options.windowType === 'sliding' ||\n      this.#timeoutIds.size === 0 // new fixed window\n    ) {\n      const now = Date.now()\n      const timeUntilExpiration = executionTime - now + this.#getWindow() + 1\n      const timeoutId = setTimeout(() => {\n        this.#cleanupOldExecutions()\n        this.#clearTimeout(timeoutId)\n      }, timeUntilExpiration)\n      this.#timeoutIds.add(timeoutId)\n    }\n  }\n\n  #clearTimeout = (timeoutId: NodeJS.Timeout): void => {\n    clearTimeout(timeoutId)\n    this.#timeoutIds.delete(timeoutId)\n  }\n\n  #clearTimeouts = (): void => {\n    this.#timeoutIds.forEach((timeoutId) => clearTimeout(timeoutId))\n    this.#timeoutIds.clear()\n  }\n\n  #cleanupOldExecutions = (): void => {\n    this.#setState({\n      executionTimes: this.#getExecutionTimesInWindow(),\n    })\n  }\n\n  /**\n   * Returns the number of remaining executions allowed in the current window\n   */\n  getRemainingInWindow = (): number => {\n    const relevantExecutionTimes = this.#getExecutionTimesInWindow()\n    return Math.max(0, this.#getLimit() - relevantExecutionTimes.length)\n  }\n\n  /**\n   * Returns the number of milliseconds until the next execution will be possible\n   */\n  getMsUntilNextWindow = (): number => {\n    if (this.getRemainingInWindow() > 0) {\n      return 0\n    }\n    const oldestExecution = this.store.state.executionTimes[0] ?? Infinity\n    return oldestExecution + this.#getWindow() - Date.now()\n  }\n\n  /**\n   * Resets the rate limiter state\n   */\n  reset = (): void => {\n    this.#setState(getDefaultRateLimiterState())\n    this.#clearTimeouts()\n  }\n}\n\n/**\n * Creates a rate-limited function that will execute the provided function up to a maximum number of times within a time window.\n *\n * Note that rate limiting is a simpler form of execution control compared to throttling or debouncing:\n * - A rate limiter will allow all executions until the limit is reached, then block all subsequent calls until the window resets\n * - A throttler ensures even spacing between executions, which can be better for consistent performance\n * - A debouncer collapses multiple calls into one, which is better for handling bursts of events\n *\n * The rate limiter supports two types of windows:\n * - 'fixed': A strict window that resets after the window period. All executions within the window count\n *   towards the limit, and the window resets completely after the period.\n * - 'sliding': A rolling window that allows executions as old ones expire. This provides a more\n *   consistent rate of execution over time.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the rate limiter\n * - Use `onExecute` callback to react to function execution and implement custom logic\n * - Use `onReject` callback to react to executions being rejected when rate limit is exceeded\n * - The state includes execution count, execution times, and rejection count\n * - State can be accessed via the underlying RateLimiter instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * Consider using throttle() or debounce() if you need more intelligent execution control. Use rate limiting when you specifically\n * need to enforce a hard limit on the number of executions within a time period.\n *\n * @example\n * ```ts\n * // Rate limit to 5 calls per minute with a sliding window\n * const rateLimited = rateLimit(makeApiCall, {\n *   limit: 5,\n *   window: 60000,\n *   windowType: 'sliding',\n *   onReject: (rateLimiter) => {\n *     console.log(`Rate limit exceeded. Try again in ${rateLimiter.getMsUntilNextWindow()}ms`);\n *   }\n * });\n *\n * // First 5 calls will execute immediately\n * // Additional calls will be rejected until the minute window resets\n * rateLimited();\n *\n * // For more even execution, consider using throttle instead:\n * const throttled = throttle(makeApiCall, { wait: 12000 }); // One call every 12 seconds\n * ```\n */\nexport function rateLimit<TFn extends AnyFunction>(\n  fn: TFn,\n  initialOptions: RateLimiterOptions<TFn>,\n) {\n  const rateLimiter = new RateLimiter(fn, initialOptions)\n  return rateLimiter.maybeExecute\n}\n"],"names":[],"mappings":"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"}