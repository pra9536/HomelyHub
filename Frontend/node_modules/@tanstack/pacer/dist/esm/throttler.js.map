{"version":3,"file":"throttler.js","sources":["../../src/throttler.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { AnyFunction } from './types'\n\nexport interface ThrottlerState<TFn extends AnyFunction> {\n  /**\n   * Number of function executions that have been completed\n   */\n  executionCount: number\n  /**\n   * Whether the throttler is waiting for the timeout to trigger execution\n   */\n  isPending: boolean\n  /**\n   * The arguments from the most recent call to maybeExecute\n   */\n  lastArgs: Parameters<TFn> | undefined\n  /**\n   * Timestamp of the last function execution in milliseconds\n   */\n  lastExecutionTime: number\n  /**\n   * Number of times maybeExecute has been called (for reduction calculations)\n   */\n  maybeExecuteCount: number\n  /**\n   * Timestamp when the next execution can occur in milliseconds\n   */\n  nextExecutionTime: number | undefined\n  /**\n   * Current execution status - 'idle' when not active, 'pending' when waiting for timeout\n   */\n  status: 'disabled' | 'idle' | 'pending'\n}\n\nfunction getDefaultThrottlerState<\n  TFn extends AnyFunction,\n>(): ThrottlerState<TFn> {\n  return {\n    executionCount: 0,\n    isPending: false,\n    lastArgs: undefined,\n    lastExecutionTime: 0,\n    nextExecutionTime: 0,\n    status: 'idle',\n    maybeExecuteCount: 0,\n  }\n}\n\n/**\n * Options for configuring a throttled function\n */\nexport interface ThrottlerOptions<TFn extends AnyFunction> {\n  /**\n   * Whether the throttler is enabled. When disabled, maybeExecute will not trigger any executions.\n   * Can be a boolean or a function that returns a boolean.\n   * Defaults to true.\n   */\n  enabled?: boolean | ((throttler: Throttler<TFn>) => boolean)\n  /**\n   * Initial state for the throttler\n   */\n  initialState?: Partial<ThrottlerState<TFn>>\n  /**\n   * A key to identify the throttler.\n   * If provided, the throttler will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Whether to execute on the leading edge of the timeout.\n   * Defaults to true.\n   */\n  leading?: boolean\n  /**\n   * Callback function that is called after the function is executed\n   */\n  onExecute?: (args: Parameters<TFn>, throttler: Throttler<TFn>) => void\n  /**\n   * Whether to execute on the trailing edge of the timeout.\n   * Defaults to true.\n   */\n  trailing?: boolean\n  /**\n   * Time window in milliseconds during which the function can only be executed once.\n   * Can be a number or a function that returns a number.\n   * Defaults to 0ms\n   */\n  wait: number | ((throttler: Throttler<TFn>) => number)\n}\n\nconst defaultOptions: Omit<\n  Required<ThrottlerOptions<any>>,\n  'initialState' | 'onExecute' | 'key'\n> = {\n  enabled: true,\n  leading: true,\n  trailing: true,\n  wait: 0,\n}\n\n/**\n * A class that creates a throttled function.\n *\n * Throttling ensures a function is called at most once within a specified time window.\n * Unlike debouncing which waits for a pause in calls, throttling guarantees consistent\n * execution timing regardless of call frequency.\n *\n * Supports both leading and trailing edge execution:\n * - Leading: Execute immediately on first call (default: true)\n * - Trailing: Execute after wait period if called during throttle (default: true)\n *\n * For collapsing rapid-fire events where you only care about the last call, consider using Debouncer.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the throttler\n * - Use `onExecute` callback to react to function execution and implement custom logic\n * - The state includes execution count, last execution time, pending status, and more\n * - State can be accessed via `throttler.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `throttler.state`\n *\n * @example\n * ```ts\n * const throttler = new Throttler(\n *   (id: string) => api.getData(id),\n *   { wait: 1000 } // Execute at most once per second\n * );\n *\n * // First call executes immediately\n * throttler.maybeExecute('123');\n *\n * // Subsequent calls within 1000ms are throttled\n * throttler.maybeExecute('123'); // Throttled\n * ```\n */\nexport class Throttler<TFn extends AnyFunction> {\n  readonly store: Store<Readonly<ThrottlerState<TFn>>> = new Store(\n    getDefaultThrottlerState(),\n  )\n  key: string | undefined\n  options: ThrottlerOptions<TFn>\n  #timeoutId: NodeJS.Timeout | undefined\n\n  constructor(\n    public fn: TFn,\n    initialOptions: ThrottlerOptions<TFn>,\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n    }\n    this.#setState(this.options.initialState ?? {})\n\n    pacerEventClient.on('d-Throttler', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state as ThrottlerState<TFn>)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the throttler options\n   */\n  setOptions = (newOptions: Partial<ThrottlerOptions<TFn>>): void => {\n    this.options = { ...this.options, ...newOptions }\n\n    // Cancel pending execution if the throttler is disabled\n    if (!this.#getEnabled()) {\n      this.cancel()\n    }\n  }\n\n  #setState = (newState: Partial<ThrottlerState<TFn>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n      const { isPending } = combinedState\n      return {\n        ...combinedState,\n        status: !this.#getEnabled()\n          ? 'disabled'\n          : isPending\n            ? 'pending'\n            : 'idle',\n      }\n    })\n    emitChange('Throttler', this)\n  }\n\n  #getEnabled = (): boolean => {\n    return !!parseFunctionOrValue(this.options.enabled, this)\n  }\n\n  #getWait = (): number => {\n    return parseFunctionOrValue(this.options.wait, this)\n  }\n\n  /**\n   * Attempts to execute the throttled function. The execution behavior depends on the throttler options:\n   *\n   * - If enough time has passed since the last execution (>= wait period):\n   *   - With leading=true: Executes immediately\n   *   - With leading=false: Waits for the next trailing execution\n   *\n   * - If within the wait period:\n   *   - With trailing=true: Schedules execution for end of wait period\n   *   - With trailing=false: Drops the execution\n   *\n   * @example\n   * ```ts\n   * const throttled = new Throttler(fn, { wait: 1000 });\n   *\n   * // First call executes immediately\n   * throttled.maybeExecute('a', 'b');\n   *\n   * // Call during wait period - gets throttled\n   * throttled.maybeExecute('c', 'd');\n   * ```\n   */\n  maybeExecute = (...args: Parameters<TFn>): void => {\n    this.#setState({\n      maybeExecuteCount: this.store.state.maybeExecuteCount + 1,\n    })\n\n    const now = Date.now()\n    const timeSinceLastExecution = now - this.store.state.lastExecutionTime\n    const wait = this.#getWait()\n\n    // Handle leading execution\n    if (this.options.leading && timeSinceLastExecution >= wait) {\n      this.#execute(...args)\n    } else {\n      // Store the most recent arguments for potential trailing execution\n      this.#setState({\n        lastArgs: args,\n      })\n      // Set up trailing execution if not already scheduled\n      if (!this.#timeoutId && this.options.trailing) {\n        // prevent large number if lastExecutionTime is undefined\n        const _timeSinceLastExecution = this.store.state.lastExecutionTime\n          ? now - this.store.state.lastExecutionTime\n          : 0\n        const timeoutDuration = wait - _timeSinceLastExecution\n        this.#setState({ isPending: true })\n        this.#timeoutId = setTimeout(() => {\n          const { lastArgs } = this.store.state\n          if (lastArgs !== undefined) {\n            this.#execute(...lastArgs)\n          }\n        }, timeoutDuration)\n      }\n    }\n  }\n\n  #execute = (...args: Parameters<TFn>): void => {\n    if (!this.#getEnabled()) return\n    this.fn(...args) // EXECUTE!\n    const lastExecutionTime = Date.now()\n    const nextExecutionTime = lastExecutionTime + this.#getWait()\n    this.#clearTimeout()\n    this.#setState({\n      executionCount: this.store.state.executionCount + 1,\n      lastExecutionTime,\n      nextExecutionTime,\n      isPending: false,\n      lastArgs: undefined,\n    })\n    this.options.onExecute?.(args, this)\n    setTimeout(() => {\n      if (!this.store.state.isPending) {\n        this.#setState({ nextExecutionTime: undefined })\n      }\n    }, this.#getWait())\n  }\n\n  /**\n   * Processes the current pending execution immediately\n   */\n  flush = (): void => {\n    if (this.store.state.isPending && this.store.state.lastArgs) {\n      this.#execute(...this.store.state.lastArgs)\n    }\n  }\n\n  #clearTimeout = (): void => {\n    if (this.#timeoutId) {\n      clearTimeout(this.#timeoutId)\n      this.#timeoutId = undefined\n    }\n  }\n\n  /**\n   * Cancels any pending trailing execution and clears internal state.\n   *\n   * If a trailing execution is scheduled (due to throttling with trailing=true),\n   * this will prevent that execution from occurring. The internal timeout and\n   * stored arguments will be cleared.\n   *\n   * Has no effect if there is no pending execution.\n   */\n  cancel = (): void => {\n    this.#clearTimeout()\n    this.#setState({\n      lastArgs: undefined,\n      isPending: false,\n    })\n  }\n\n  /**\n   * Resets the throttler state to its default values\n   */\n  reset = (): void => {\n    this.#setState(getDefaultThrottlerState<TFn>())\n  }\n}\n\n/**\n * Creates a throttled function that limits how often the provided function can execute.\n *\n * Throttling ensures a function executes at most once within a specified time window,\n * regardless of how many times it is called. This is useful for rate-limiting\n * expensive operations or UI updates.\n *\n * The throttled function can be configured to execute on the leading and/or trailing\n * edge of the throttle window via options.\n *\n * For handling bursts of events, consider using debounce() instead. For hard execution\n * limits, consider using rateLimit().\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the throttler\n * - Use `onExecute` callback to react to function execution and implement custom logic\n * - The state includes execution count, last execution time, pending status, and more\n * - State can be accessed via the underlying Throttler instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * @example\n * ```ts\n * // Basic throttling - max once per second\n * const throttled = throttle(updateUI, { wait: 1000 });\n *\n * // Configure leading/trailing execution\n * const throttled = throttle(saveData, {\n *   wait: 2000,\n *   leading: true,  // Execute immediately on first call\n *   trailing: true  // Execute again after delay if called during wait\n * });\n * ```\n */\nexport function throttle<TFn extends AnyFunction>(\n  fn: TFn,\n  initialOptions: ThrottlerOptions<TFn>,\n) {\n  const throttler = new Throttler(fn, initialOptions)\n  return throttler.maybeExecute\n}\n"],"names":[],"mappings":"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"}