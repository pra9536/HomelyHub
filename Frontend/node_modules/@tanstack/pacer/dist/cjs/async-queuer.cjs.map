{"version":3,"file":"async-queuer.cjs","sources":["../../src/async-queuer.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { OptionalKeys } from './types'\nimport type { QueuePosition } from './queuer'\n\nexport interface AsyncQueuerState<TValue> {\n  /**\n   * Items currently being processed by the queuer\n   */\n  activeItems: Array<TValue>\n  /**\n   * Number of times addItem has been called (for reduction calculations)\n   */\n  addItemCount: number\n  /**\n   * Number of task executions that have resulted in errors\n   */\n  errorCount: number\n  /**\n   * Number of items that have been removed from the queue due to expiration\n   */\n  expirationCount: number\n  /**\n   * Whether the queuer has no items to process (items array is empty)\n   */\n  isEmpty: boolean\n  /**\n   * Whether the queuer has reached its maximum capacity\n   */\n  isFull: boolean\n  /**\n   * Whether the queuer is not currently processing any items\n   */\n  isIdle: boolean\n  /**\n   * Whether the queuer is active and will process items automatically\n   */\n  isRunning: boolean\n  /**\n   * Array of items currently waiting to be processed\n   */\n  items: Array<TValue>\n  /**\n   * Timestamps when items were added to the queue for expiration tracking\n   */\n  itemTimestamps: Array<number>\n  /**\n   * The result from the most recent task execution\n   */\n  lastResult: any\n  /**\n   * Whether the queuer has a pending timeout for processing the next item\n   */\n  pendingTick: boolean\n  /**\n   * Number of items that have been rejected from being added to the queue\n   */\n  rejectionCount: number\n  /**\n   * Number of task executions that have completed (either successfully or with errors)\n   */\n  settledCount: number\n  /**\n   * Number of items currently in the queue\n   */\n  size: number\n  /**\n   * Current processing status - 'idle' when not processing, 'running' when active, 'stopped' when paused\n   */\n  status: 'idle' | 'running' | 'stopped'\n  /**\n   * Number of task executions that have completed successfully\n   */\n  successCount: number\n}\n\nfunction getDefaultAsyncQueuerState<TValue>(): AsyncQueuerState<TValue> {\n  return {\n    activeItems: [],\n    addItemCount: 0,\n    errorCount: 0,\n    expirationCount: 0,\n    isEmpty: true,\n    isFull: false,\n    isIdle: true,\n    isRunning: true,\n    itemTimestamps: [],\n    items: [],\n    lastResult: null,\n    pendingTick: false,\n    rejectionCount: 0,\n    settledCount: 0,\n    size: 0,\n    status: 'idle',\n    successCount: 0,\n  }\n}\n\nexport interface AsyncQueuerOptions<TValue> {\n  /**\n   * Default position to add items to the queuer\n   * @default 'back'\n   */\n  addItemsTo?: QueuePosition\n  /**\n   * Maximum number of concurrent tasks to process.\n   * Can be a number or a function that returns a number.\n   * @default 1\n   */\n  concurrency?: number | ((queuer: AsyncQueuer<TValue>) => number)\n  /**\n   * Maximum time in milliseconds that an item can stay in the queue\n   * If not provided, items will never expire\n   */\n  expirationDuration?: number\n  /**\n   * Function to determine if an item has expired\n   * If provided, this overrides the expirationDuration behavior\n   */\n  getIsExpired?: (item: TValue, addedAt: number) => boolean\n  /**\n   * Default position to get items from during processing\n   * @default 'front'\n   */\n  getItemsFrom?: QueuePosition\n  /**\n   * Function to determine priority of items in the queuer\n   * Higher priority items will be processed first\n   * If not provided, will use static priority values attached to tasks\n   */\n  getPriority?: (item: TValue) => number\n  /**\n   * Initial items to populate the queuer with\n   */\n  initialItems?: Array<TValue>\n  /**\n   * Initial state for the async queuer\n   */\n  initialState?: Partial<AsyncQueuerState<TValue>>\n  /**\n   * Optional key to identify this async queuer instance.\n   * If provided, the async queuer will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Maximum number of items allowed in the queuer\n   */\n  maxSize?: number\n  /**\n   * Optional error handler for when a task throws.\n   * If provided, the handler will be called with the error and queuer instance.\n   * This can be used alongside throwOnError - the handler will be called before any error is thrown.\n   */\n  onError?: (error: unknown, item: TValue, queuer: AsyncQueuer<TValue>) => void\n  /**\n   * Callback fired whenever an item expires in the queuer\n   */\n  onExpire?: (item: TValue, queuer: AsyncQueuer<TValue>) => void\n  /**\n   * Callback fired whenever an item is added or removed from the queuer\n   */\n  onItemsChange?: (queuer: AsyncQueuer<TValue>) => void\n  /**\n   * Callback fired whenever an item is rejected from being added to the queuer\n   */\n  onReject?: (item: TValue, queuer: AsyncQueuer<TValue>) => void\n  /**\n   * Optional callback to call when a task is settled\n   */\n  onSettled?: (item: TValue, queuer: AsyncQueuer<TValue>) => void\n  /**\n   * Optional callback to call when a task succeeds\n   */\n  onSuccess?: (result: any, item: TValue, queuer: AsyncQueuer<TValue>) => void\n  /**\n   * Whether the queuer should start processing tasks immediately or not.\n   */\n  started?: boolean\n  /**\n   * Whether to throw errors when they occur.\n   * Defaults to true if no onError handler is provided, false if an onError handler is provided.\n   * Can be explicitly set to override these defaults.\n   */\n  throwOnError?: boolean\n  /**\n   * Time in milliseconds to wait between processing items.\n   * Can be a number or a function that returns a number.\n   * @default 0\n   */\n  wait?: number | ((queuer: AsyncQueuer<TValue>) => number)\n}\n\ntype AsyncQueuerOptionsWithOptionalCallbacks = OptionalKeys<\n  Required<AsyncQueuerOptions<any>>,\n  | 'initialState'\n  | 'throwOnError'\n  | 'onSuccess'\n  | 'onSettled'\n  | 'onReject'\n  | 'onItemsChange'\n  | 'onExpire'\n  | 'onError'\n  | 'key'\n>\n\nconst defaultOptions: AsyncQueuerOptionsWithOptionalCallbacks = {\n  addItemsTo: 'back',\n  concurrency: 1,\n  expirationDuration: Infinity,\n  getIsExpired: () => false,\n  getItemsFrom: 'front',\n  getPriority: (item: any) => item?.priority ?? 0,\n  initialItems: [],\n  maxSize: Infinity,\n  started: true,\n  wait: 0,\n}\n\n/**\n * A flexible asynchronous queue for processing tasks with configurable concurrency, priority, and expiration.\n *\n * Features:\n * - Priority queue support via the getPriority option\n * - Configurable concurrency limit\n * - Callbacks for task success, error, completion, and queue state changes\n * - FIFO (First In First Out) or LIFO (Last In First Out) queue behavior\n * - Pause and resume processing\n * - Task cancellation\n * - Item expiration to remove stale items from the queue\n *\n * Tasks are processed concurrently up to the configured concurrency limit. When a task completes,\n * the next pending task is processed if the concurrency limit allows.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and queuer instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together; the handler will be called before any error is thrown\n * - The error state can be checked using the AsyncQueuer instance\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the async queuer\n * - Use `onSuccess` callback to react to successful task execution and implement custom logic\n * - Use `onError` callback to react to task execution errors and implement custom error handling\n * - Use `onSettled` callback to react to task execution completion (success or error) and implement custom logic\n * - Use `onItemsChange` callback to react to items being added or removed from the queue\n * - Use `onExpire` callback to react to items expiring and implement custom logic\n * - Use `onReject` callback to react to items being rejected when the queue is full\n * - The state includes error count, expiration count, rejection count, running status, and success/settle counts\n * - State can be accessed via `asyncQueuer.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `asyncQueuer.state`\n *\n * Example usage:\n * ```ts\n * const asyncQueuer = new AsyncQueuer<string>(async (item) => {\n *   // process item\n *   return item.toUpperCase();\n * }, {\n *   concurrency: 2,\n *   onSuccess: (result) => {\n *     console.log(result);\n *   }\n * });\n *\n * asyncQueuer.addItem('hello');\n * asyncQueuer.start();\n * ```\n */\nexport class AsyncQueuer<TValue> {\n  readonly store: Store<Readonly<AsyncQueuerState<TValue>>> = new Store<\n    AsyncQueuerState<TValue>\n  >(getDefaultAsyncQueuerState<TValue>())\n  key: string\n  options: AsyncQueuerOptions<TValue>\n  #timeoutIds: Set<NodeJS.Timeout> = new Set()\n\n  constructor(\n    public fn: (item: TValue) => Promise<any>,\n    initialOptions: AsyncQueuerOptions<TValue> = {},\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n      throwOnError: initialOptions.throwOnError ?? !initialOptions.onError,\n    }\n    const isInitiallyRunning =\n      this.options.initialState?.isRunning ?? this.options.started ?? true\n    this.#setState({\n      ...this.options.initialState,\n      isRunning: isInitiallyRunning,\n    })\n\n    if (this.options.initialState?.items) {\n      if (this.store.state.isRunning) {\n        this.#tick()\n      }\n    } else {\n      for (let i = 0; i < (this.options.initialItems?.length ?? 0); i++) {\n        const item = this.options.initialItems![i]!\n        const isLast = i === (this.options.initialItems?.length ?? 0) - 1\n        this.addItem(item, this.options.addItemsTo ?? 'back', isLast)\n      }\n    }\n\n    pacerEventClient.on('d-AsyncQueuer', (e) => {\n      if (e.payload.key !== this.key) return\n      this.#setState(e.payload.store.state)\n      this.setOptions(e.payload.options)\n    })\n  }\n\n  /**\n   * Updates the queuer options. New options are merged with existing options.\n   */\n  setOptions = (newOptions: Partial<AsyncQueuerOptions<TValue>>): void => {\n    this.options = { ...this.options, ...newOptions }\n  }\n\n  #setState = (newState: Partial<AsyncQueuerState<TValue>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n\n      const { activeItems, items, isRunning } = combinedState\n\n      const size = items.length\n      const isFull = size >= (this.options.maxSize ?? Infinity)\n      const isEmpty = size === 0\n      const isIdle = isRunning && isEmpty && activeItems.length === 0\n\n      const status = isIdle ? 'idle' : isRunning ? 'running' : 'stopped'\n\n      return {\n        ...combinedState,\n        isEmpty,\n        isFull,\n        isIdle,\n        size,\n        status,\n      }\n    })\n    emitChange('AsyncQueuer', this)\n  }\n\n  /**\n   * Returns the current wait time (in milliseconds) between processing items.\n   * If a function is provided, it is called with the queuer instance.\n   */\n  #getWait = (): number => {\n    return parseFunctionOrValue(this.options.wait ?? 0, this)\n  }\n\n  /**\n   * Returns the current concurrency limit for processing items.\n   * If a function is provided, it is called with the queuer instance.\n   */\n  #getConcurrency = (): number => {\n    return parseFunctionOrValue(this.options.concurrency ?? 1, this)\n  }\n\n  /**\n   * Processes items in the queue up to the concurrency limit. Internal use only.\n   */\n  #tick = () => {\n    if (!this.store.state.isRunning) {\n      this.#setState({ pendingTick: false })\n      return\n    }\n    this.#setState({ pendingTick: true })\n\n    // Check for expired items\n    this.#checkExpiredItems()\n\n    // Process items concurrently up to the concurrency limit\n    const activeItems = this.store.state.activeItems\n    while (\n      activeItems.length < this.#getConcurrency() &&\n      this.store.state.items.length > 0\n    ) {\n      const nextItem = this.peekNextItem()\n      if (!nextItem) {\n        break\n      }\n      activeItems.push(nextItem)\n      this.#setState({\n        activeItems,\n      })\n      ;(async () => {\n        const result = await this.execute()\n        this.#setState({ lastResult: result })\n\n        const wait = this.#getWait()\n        if (wait > 0) {\n          const timeoutId = setTimeout(() => this.#tick(), wait)\n          this.#timeoutIds.add(timeoutId)\n          return\n        }\n\n        this.#tick()\n      })()\n    }\n\n    this.#setState({ pendingTick: false })\n  }\n\n  /**\n   * Adds an item to the queue. If the queue is full, the item is rejected and onReject is called.\n   * Items can be inserted based on priority or at the front/back depending on configuration.\n   *\n   * @example\n   * ```ts\n   * queuer.addItem({ value: 'task', priority: 10 });\n   * queuer.addItem('task2', 'front');\n   * ```\n   */\n  addItem = (\n    item: TValue,\n    position: QueuePosition = this.options.addItemsTo ?? 'back',\n    runOnItemsChange: boolean = true,\n  ): boolean => {\n    this.#setState({\n      addItemCount: this.store.state.addItemCount + 1,\n    })\n\n    if (this.store.state.items.length >= (this.options.maxSize ?? Infinity)) {\n      this.#setState({\n        rejectionCount: this.store.state.rejectionCount + 1,\n      })\n      this.options.onReject?.(item, this)\n      return false\n    }\n\n    // Get priority either from the function or from getPriority option\n    const priority =\n      this.options.getPriority !== defaultOptions.getPriority\n        ? this.options.getPriority!(item)\n        : (item as any).priority\n\n    const items = this.store.state.items\n    const itemTimestamps = this.store.state.itemTimestamps\n\n    if (priority !== undefined) {\n      // Insert based on priority - higher priority items go to front\n      const insertIndex = items.findIndex((existing) => {\n        const existingPriority =\n          this.options.getPriority !== defaultOptions.getPriority\n            ? this.options.getPriority!(existing)\n            : (existing as any).priority\n        return existingPriority < priority\n      })\n\n      if (insertIndex === -1) {\n        items.push(item)\n        itemTimestamps.push(Date.now())\n      } else {\n        items.splice(insertIndex, 0, item)\n        itemTimestamps.splice(insertIndex, 0, Date.now())\n      }\n    } else {\n      if (position === 'front') {\n        // Default FIFO/LIFO behavior\n        items.unshift(item)\n        itemTimestamps.unshift(Date.now())\n      } else {\n        // LIFO\n        items.push(item)\n        itemTimestamps.push(Date.now())\n      }\n    }\n\n    this.#setState({\n      items,\n      itemTimestamps,\n    })\n\n    if (runOnItemsChange) {\n      this.options.onItemsChange?.(this)\n    }\n\n    if (this.store.state.isRunning && !this.store.state.pendingTick) {\n      this.#tick()\n    }\n\n    return true\n  }\n\n  /**\n   * Removes and returns the next item from the queue without executing the task function.\n   * Use for manual queue management. Normally, use execute() to process items.\n   *\n   * @example\n   * ```ts\n   * // FIFO\n   * queuer.getNextItem();\n   * // LIFO\n   * queuer.getNextItem('back');\n   * ```\n   */\n  getNextItem = (\n    position: QueuePosition = this.options.getItemsFrom ?? 'front',\n  ): TValue | undefined => {\n    const { items, itemTimestamps } = this.store.state\n    let item: TValue | undefined\n\n    // When priority function is provided or position is 'front', always get from front (highest priority)\n    // Priority takes precedence over FIFO/LIFO behavior\n    if (\n      this.options.getPriority !== defaultOptions.getPriority ||\n      position === 'front'\n    ) {\n      item = items[0]\n      if (item !== undefined) {\n        this.#setState({\n          items: items.slice(1),\n          itemTimestamps: itemTimestamps.slice(1),\n        })\n      }\n    } else {\n      item = items[items.length - 1]\n      if (item !== undefined) {\n        this.#setState({\n          items: items.slice(0, -1),\n          itemTimestamps: itemTimestamps.slice(0, -1),\n        })\n      }\n    }\n\n    if (item !== undefined) {\n      this.options.onItemsChange?.(this)\n    }\n\n    return item\n  }\n\n  #getAllItems = (): Array<TValue> => {\n    const items = this.peekAllItems()\n    this.clear()\n    return items\n  }\n\n  /**\n   * Removes and returns the next item from the queue and executes the task function with it.\n   *\n   * @example\n   * ```ts\n   * queuer.execute();\n   * // LIFO\n   * queuer.execute('back');\n   * ```\n   */\n  execute = async (position?: QueuePosition): Promise<any> => {\n    const item = this.getNextItem(position)\n    if (item !== undefined) {\n      try {\n        const lastResult = await this.fn(item) // EXECUTE!\n        this.#setState({\n          successCount: this.store.state.successCount + 1,\n          lastResult,\n        })\n        this.options.onSuccess?.(lastResult, item, this)\n      } catch (error) {\n        this.#setState({\n          errorCount: this.store.state.errorCount + 1,\n        })\n        this.options.onError?.(error, item, this)\n        if (this.options.throwOnError) {\n          throw error\n        }\n      } finally {\n        this.#setState({\n          activeItems: this.store.state.activeItems.filter(\n            (activeItem) => activeItem !== item,\n          ),\n          settledCount: this.store.state.settledCount + 1,\n        })\n        this.options.onSettled?.(item, this)\n      }\n    }\n    return item\n  }\n\n  /**\n   * Processes a specified number of items to execute immediately with no wait time\n   * If no numberOfItems is provided, all items will be processed\n   */\n  flush = async (\n    numberOfItems: number = this.store.state.items.length,\n    position?: QueuePosition,\n  ): Promise<void> => {\n    this.#clearTimeouts() // clear any pending timeouts\n    await Promise.all(\n      Array.from({ length: numberOfItems }, () => this.execute(position)),\n    )\n  }\n\n  /**\n   * Processes all items in the queue as a batch using the provided function as an argument\n   * The queue is cleared after processing\n   */\n  flushAsBatch = async (\n    batchFunction: (items: Array<TValue>) => Promise<any>,\n  ): Promise<void> => {\n    this.#clearTimeouts() // clear any pending timeouts\n    const items = this.#getAllItems()\n    await batchFunction(items)\n  }\n\n  /**\n   * Checks for expired items in the queue and removes them. Calls onExpire for each expired item.\n   * Internal use only.\n   */\n  #checkExpiredItems = (): void => {\n    if (\n      (this.options.expirationDuration ?? Infinity) === Infinity &&\n      this.options.getIsExpired === defaultOptions.getIsExpired\n    ) {\n      return\n    }\n\n    const now = Date.now()\n    const expiredIndices: Array<number> = []\n\n    // Find indices of expired items\n    for (let i = 0; i < this.store.state.items.length; i++) {\n      const timestamp = this.store.state.itemTimestamps[i]\n      if (timestamp === undefined) continue\n\n      const item = this.store.state.items[i]\n      if (item === undefined) continue\n\n      const isExpired =\n        this.options.getIsExpired !== defaultOptions.getIsExpired\n          ? this.options.getIsExpired!(item, timestamp)\n          : now - timestamp > (this.options.expirationDuration ?? Infinity)\n\n      if (isExpired) {\n        expiredIndices.push(i)\n      }\n    }\n\n    // Remove expired items from back to front to maintain indices\n    for (let i = expiredIndices.length - 1; i >= 0; i--) {\n      const index = expiredIndices[i]\n      if (index === undefined) continue\n\n      const expiredItem = this.store.state.items[index]\n      if (expiredItem === undefined) continue\n\n      const newItems = [...this.store.state.items]\n      const newTimestamps = [...this.store.state.itemTimestamps]\n      newItems.splice(index, 1)\n      newTimestamps.splice(index, 1)\n      this.#setState({\n        items: newItems,\n        itemTimestamps: newTimestamps,\n        expirationCount: this.store.state.expirationCount + 1,\n      })\n      this.options.onExpire?.(expiredItem, this)\n    }\n\n    if (expiredIndices.length > 0) {\n      this.options.onItemsChange?.(this)\n    }\n  }\n\n  /**\n   * Returns the next item in the queue without removing it.\n   *\n   * @example\n   * ```ts\n   * queuer.peekNextItem(); // front\n   * queuer.peekNextItem('back'); // back\n   * ```\n   */\n  peekNextItem = (position: QueuePosition = 'front'): TValue | undefined => {\n    if (position === 'front') {\n      return this.store.state.items[0]\n    }\n    return this.store.state.items[this.store.state.items.length - 1]\n  }\n\n  /**\n   * Returns a copy of all items in the queue, including active and pending items.\n   */\n  peekAllItems = (): Array<TValue> => {\n    return [...this.peekActiveItems(), ...this.peekPendingItems()]\n  }\n\n  /**\n   * Returns the items currently being processed (active tasks).\n   */\n  peekActiveItems = (): Array<TValue> => {\n    return [...this.store.state.activeItems]\n  }\n\n  /**\n   * Returns the items waiting to be processed (pending tasks).\n   */\n  peekPendingItems = (): Array<TValue> => {\n    return [...this.store.state.items]\n  }\n\n  /**\n   * Starts processing items in the queue. If already running, does nothing.\n   */\n  start = (): void => {\n    this.#setState({ isRunning: true })\n    if (!this.store.state.pendingTick && this.store.state.items.length > 0) {\n      this.#tick()\n    }\n  }\n\n  /**\n   * Stops processing items in the queue. Does not clear the queue.\n   */\n  stop = (): void => {\n    this.#clearTimeouts()\n    this.#setState({ isRunning: false, pendingTick: false })\n  }\n\n  #clearTimeouts = (): void => {\n    this.#timeoutIds.forEach((timeoutId) => clearTimeout(timeoutId))\n    this.#timeoutIds.clear()\n  }\n\n  /**\n   * Removes all pending items from the queue. Does not affect active tasks.\n   */\n  clear = (): void => {\n    this.#setState({ items: [], itemTimestamps: [] })\n    this.options.onItemsChange?.(this)\n  }\n\n  /**\n   * Resets the queuer state to its default values\n   */\n  reset = (): void => {\n    this.#setState(getDefaultAsyncQueuerState<TValue>())\n    this.options.onItemsChange?.(this)\n  }\n}\n\n/**\n * Creates a new AsyncQueuer instance and returns a bound addItem function for adding tasks.\n * The queuer is started automatically and ready to process items.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and queuer instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together; the handler will be called before any error is thrown\n * - The error state can be checked using the underlying AsyncQueuer instance\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the async queuer\n * - Use `onSuccess` callback to react to successful task execution and implement custom logic\n * - Use `onError` callback to react to task execution errors and implement custom error handling\n * - Use `onSettled` callback to react to task execution completion (success or error) and implement custom logic\n * - Use `onItemsChange` callback to react to items being added or removed from the queue\n * - Use `onExpire` callback to react to items expiring and implement custom logic\n * - Use `onReject` callback to react to items being rejected when the queue is full\n * - The state includes error count, expiration count, rejection count, running status, and success/settle counts\n * - State can be accessed via the underlying AsyncQueuer instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * Example usage:\n * ```ts\n * const enqueue = asyncQueue<string>(async (item) => {\n *   return item.toUpperCase();\n * }, {...options});\n *\n * enqueue('hello');\n * ```\n */\nexport function asyncQueue<TValue>(\n  fn: (value: TValue) => Promise<any>,\n  initialOptions: AsyncQueuerOptions<TValue>,\n) {\n  const asyncQueuer = new AsyncQueuer<TValue>(fn, initialOptions)\n  return asyncQueuer.addItem\n}\n"],"names":["Store","emitChange","parseFunctionOrValue","createKey","pacerEventClient"],"mappings":"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"}