{"version":3,"file":"async-rate-limiter.cjs","sources":["../../src/async-rate-limiter.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { AnyAsyncFunction } from './types'\n\nexport interface AsyncRateLimiterState<TFn extends AnyAsyncFunction> {\n  /**\n   * Number of function executions that have resulted in errors\n   */\n  errorCount: number\n  /**\n   * Array of timestamps when executions occurred for rate limiting calculations\n   */\n  executionTimes: Array<number>\n  /**\n   * Whether the rate limiter has exceeded the limit\n   */\n  isExceeded: boolean\n  /**\n   * Whether the rate-limited function is currently executing asynchronously\n   */\n  isExecuting: boolean\n  /**\n   * The result from the most recent successful function execution\n   */\n  lastResult: ReturnType<TFn> | undefined\n  /**\n   * Number of function executions that have been rejected due to rate limiting\n   */\n  rejectionCount: number\n  /**\n   * Number of function executions that have completed (either successfully or with errors)\n   */\n  settleCount: number\n  /**\n   * Current execution status - 'disabled' when not active, 'executing' when executing, 'idle' when not executing, 'exceeded' when rate limit is exceeded\n   */\n  status: 'disabled' | 'executing' | 'exceeded' | 'idle'\n  /**\n   * Number of function executions that have completed successfully\n   */\n  successCount: number\n  /**\n   * Number of times maybeExecute has been called (for reduction calculations)\n   */\n  maybeExecuteCount: number\n}\n\nfunction getDefaultAsyncRateLimiterState<\n  TFn extends AnyAsyncFunction,\n>(): AsyncRateLimiterState<TFn> {\n  return {\n    errorCount: 0,\n    executionTimes: [],\n    isExceeded: false,\n    isExecuting: false,\n    lastResult: undefined,\n    maybeExecuteCount: 0,\n    rejectionCount: 0,\n    settleCount: 0,\n    status: 'idle',\n    successCount: 0,\n  }\n}\n\n/**\n * Options for configuring an async rate-limited function\n */\nexport interface AsyncRateLimiterOptions<TFn extends AnyAsyncFunction> {\n  /**\n   * Whether the rate limiter is enabled. When disabled, maybeExecute will not trigger any executions.\n   * Can be a boolean or a function that returns a boolean.\n   * Defaults to true.\n   */\n  enabled?: boolean | ((rateLimiter: AsyncRateLimiter<TFn>) => boolean)\n  /**\n   * Initial state for the rate limiter\n   */\n  initialState?: Partial<AsyncRateLimiterState<TFn>>\n  /**\n   * Optional key to identify this async rate limiter instance.\n   * If provided, the async rate limiter will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Maximum number of executions allowed within the time window.\n   * Can be a number or a function that returns a number.\n   */\n  limit: number | ((rateLimiter: AsyncRateLimiter<TFn>) => number)\n  /**\n   * Optional error handler for when the rate-limited function throws.\n   * If provided, the handler will be called with the error and rate limiter instance.\n   * This can be used alongside throwOnError - the handler will be called before any error is thrown.\n   */\n  onError?: (\n    error: unknown,\n    args: Parameters<TFn>,\n    rateLimiter: AsyncRateLimiter<TFn>,\n  ) => void\n  /**\n   * Optional callback function that is called when an execution is rejected due to rate limiting\n   */\n  onReject?: (args: Parameters<TFn>, rateLimiter: AsyncRateLimiter<TFn>) => void\n  /**\n   * Optional function to call when the rate-limited function is executed\n   */\n  onSettled?: (\n    args: Parameters<TFn>,\n    rateLimiter: AsyncRateLimiter<TFn>,\n  ) => void\n  /**\n   * Optional function to call when the rate-limited function is executed\n   */\n  onSuccess?: (\n    result: ReturnType<TFn>,\n    args: Parameters<TFn>,\n    rateLimiter: AsyncRateLimiter<TFn>,\n  ) => void\n  /**\n   * Whether to throw errors when they occur.\n   * Defaults to true if no onError handler is provided, false if an onError handler is provided.\n   * Can be explicitly set to override these defaults.\n   */\n  throwOnError?: boolean\n  /**\n   * Time window in milliseconds within which the limit applies.\n   * Can be a number or a function that returns a number.\n   */\n  window: number | ((rateLimiter: AsyncRateLimiter<TFn>) => number)\n  /**\n   * Type of window to use for rate limiting\n   * - 'fixed': Uses a fixed window that resets after the window period\n   * - 'sliding': Uses a sliding window that allows executions as old ones expire\n   * Defaults to 'fixed'\n   */\n  windowType?: 'fixed' | 'sliding'\n}\n\nconst defaultOptions: Omit<\n  Required<AsyncRateLimiterOptions<any>>,\n  'initialState' | 'onError' | 'onReject' | 'onSettled' | 'onSuccess' | 'key'\n> = {\n  enabled: true,\n  limit: 1,\n  window: 0,\n  windowType: 'fixed',\n  throwOnError: true,\n}\n\n/**\n * A class that creates an async rate-limited function.\n *\n * Rate limiting is a simple approach that allows a function to execute up to a limit within a time window,\n * then blocks all subsequent calls until the window passes. This can lead to \"bursty\" behavior where\n * all executions happen immediately, followed by a complete block.\n *\n * The rate limiter supports two types of windows:\n * - 'fixed': A strict window that resets after the window period. All executions within the window count\n *   towards the limit, and the window resets completely after the period.\n * - 'sliding': A rolling window that allows executions as old ones expire. This provides a more\n *   consistent rate of execution over time.\n *\n * Unlike the non-async RateLimiter, this async version supports returning values from the rate-limited function,\n * making it ideal for API calls and other async operations where you want the result of the `maybeExecute` call\n * instead of setting the result on a state variable from within the rate-limited function.\n *\n * For smoother execution patterns, consider using:\n * - Throttling: Ensures consistent spacing between executions (e.g. max once per 200ms)\n * - Debouncing: Waits for a pause in calls before executing (e.g. after 500ms of no calls)\n *\n * Rate limiting is best used for hard API limits or resource constraints. For UI updates or\n * smoothing out frequent events, throttling or debouncing usually provide better user experience.\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the rate limiter\n * - `initialState` can be a partial state object\n * - Use `onSuccess` callback to react to successful function execution and implement custom logic\n * - Use `onError` callback to react to function execution errors and implement custom error handling\n * - Use `onSettled` callback to react to function execution completion (success or error) and implement custom logic\n * - Use `onReject` callback to react to executions being rejected when rate limit is exceeded\n * - The state includes execution times, success/error counts, and current execution status\n * - State can be accessed via `asyncRateLimiter.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `asyncRateLimiter.state`\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and rate limiter instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together - the handler will be called before any error is thrown\n * - The error state can be checked using the underlying AsyncRateLimiter instance\n * - Rate limit rejections (when limit is exceeded) are handled separately from execution errors via the `onReject` handler\n *\n * @example\n * ```ts\n * const rateLimiter = new AsyncRateLimiter(\n *   async (id: string) => await api.getData(id),\n *   {\n *     limit: 5,\n *     window: 1000,\n *     windowType: 'sliding',\n *     onError: (error) => {\n *       console.error('API call failed:', error);\n *     },\n *     onReject: (limiter) => {\n *       console.log(`Rate limit exceeded. Try again in ${limiter.getMsUntilNextWindow()}ms`);\n *     }\n *   }\n * );\n *\n * // Will execute immediately until limit reached, then block\n * // Returns the API response directly\n * const data = await rateLimiter.maybeExecute('123');\n * ```\n */\nexport class AsyncRateLimiter<TFn extends AnyAsyncFunction> {\n  readonly store: Store<Readonly<AsyncRateLimiterState<TFn>>> = new Store<\n    AsyncRateLimiterState<TFn>\n  >(getDefaultAsyncRateLimiterState<TFn>())\n  key: string\n  options: AsyncRateLimiterOptions<TFn>\n  #timeoutIds: Set<NodeJS.Timeout> = new Set()\n\n  constructor(\n    public fn: TFn,\n    initialOptions: AsyncRateLimiterOptions<TFn>,\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n      throwOnError: initialOptions.throwOnError ?? !initialOptions.onError,\n    }\n    this.#setState(this.options.initialState ?? {})\n    for (const executionTime of this.#getExecutionTimesInWindow()) {\n      this.#setCleanupTimeout(executionTime)\n    }\n\n    pacerEventClient.on('d-AsyncRateLimiter', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the async rate limiter options\n   */\n  setOptions = (newOptions: Partial<AsyncRateLimiterOptions<TFn>>): void => {\n    this.options = { ...this.options, ...newOptions }\n  }\n\n  #setState = (newState: Partial<AsyncRateLimiterState<TFn>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n      const isExceeded = combinedState.executionTimes.length >= this.#getLimit()\n      const status = !this.#getEnabled()\n        ? 'disabled'\n        : combinedState.isExecuting\n          ? 'executing'\n          : isExceeded\n            ? 'exceeded'\n            : 'idle'\n      return {\n        ...combinedState,\n        isExceeded,\n        status,\n      }\n    })\n    emitChange('AsyncRateLimiter', this)\n  }\n\n  /**\n   * Returns the current enabled state of the async rate limiter\n   */\n  #getEnabled = (): boolean => {\n    return !!parseFunctionOrValue(this.options.enabled, this)\n  }\n\n  /**\n   * Returns the current limit of executions allowed within the time window\n   */\n  #getLimit = (): number => {\n    return parseFunctionOrValue(this.options.limit, this)\n  }\n\n  /**\n   * Returns the current time window in milliseconds\n   */\n  #getWindow = (): number => {\n    return parseFunctionOrValue(this.options.window, this)\n  }\n\n  /**\n   * Attempts to execute the rate-limited function if within the configured limits.\n   * Will reject execution if the number of calls in the current window exceeds the limit.\n   *\n   * Error Handling:\n   * - If the rate-limited function throws and no `onError` handler is configured,\n   *   the error will be thrown from this method.\n   * - If an `onError` handler is configured, errors will be caught and passed to the handler,\n   *   and this method will return undefined.\n   * - The error state can be checked using `getErrorCount()` and `getIsExecuting()`.\n   *\n   * @returns A promise that resolves with the function's return value, or undefined if an error occurred and was handled by onError\n   * @throws The error from the rate-limited function if no onError handler is configured\n   *\n   * @example\n   * ```ts\n   * const rateLimiter = new AsyncRateLimiter(fn, { limit: 5, window: 1000 });\n   *\n   * // First 5 calls will return a promise that resolves with the result\n   * const result = await rateLimiter.maybeExecute('arg1', 'arg2');\n   *\n   * // Additional calls within the window will return undefined\n   * const result2 = await rateLimiter.maybeExecute('arg1', 'arg2'); // undefined\n   * ```\n   */\n  maybeExecute = async (\n    ...args: Parameters<TFn>\n  ): Promise<ReturnType<TFn> | undefined> => {\n    this.#setState({\n      maybeExecuteCount: this.store.state.maybeExecuteCount + 1,\n    })\n\n    this.#cleanupOldExecutions()\n\n    const relevantExecutionTimes = this.#getExecutionTimesInWindow()\n\n    if (relevantExecutionTimes.length < this.#getLimit()) {\n      await this.#execute(...args)\n      return this.store.state.lastResult\n    }\n\n    this.#setState({\n      rejectionCount: this.store.state.rejectionCount + 1,\n    })\n    this.options.onReject?.(args, this)\n    return undefined\n  }\n\n  #execute = async (\n    ...args: Parameters<TFn>\n  ): Promise<ReturnType<TFn> | undefined> => {\n    if (!this.#getEnabled()) return\n\n    const now = Date.now()\n    const executionTimes = [...this.store.state.executionTimes, now]\n    this.#setState({\n      isExecuting: true,\n      executionTimes,\n    })\n\n    try {\n      const result = await this.fn(...args) // EXECUTE!\n      this.#setCleanupTimeout(now)\n      this.#setState({\n        successCount: this.store.state.successCount + 1,\n        lastResult: result,\n      })\n      this.options.onSuccess?.(result, args, this)\n    } catch (error) {\n      this.#setState({\n        errorCount: this.store.state.errorCount + 1,\n      })\n      this.options.onError?.(error, args, this)\n      if (this.options.throwOnError) {\n        throw error\n      }\n    } finally {\n      this.#setState({\n        isExecuting: false,\n        settleCount: this.store.state.settleCount + 1,\n      })\n      this.options.onSettled?.(args, this)\n    }\n\n    return this.store.state.lastResult\n  }\n\n  #getExecutionTimesInWindow = (): Array<number> => {\n    if (this.options.windowType === 'sliding') {\n      // For sliding window, return all executions within the current window\n      return this.store.state.executionTimes.filter(\n        (time) => time > Date.now() - this.#getWindow(),\n      )\n    } else {\n      // For fixed window, return all executions in the current window\n      // The window starts from the oldest execution time\n      if (this.store.state.executionTimes.length === 0) {\n        return []\n      }\n      const oldestExecution = Math.min(...this.store.state.executionTimes)\n      const windowStart = oldestExecution\n      const windowEnd = windowStart + this.#getWindow()\n      const now = Date.now()\n\n      // If the window has expired, return empty array\n      if (now > windowEnd) {\n        return []\n      }\n\n      // Otherwise, return all executions in the current window\n      return this.store.state.executionTimes.filter(\n        (time) => time >= windowStart && time <= windowEnd,\n      )\n    }\n  }\n\n  #setCleanupTimeout = (executionTime: number): void => {\n    if (\n      this.options.windowType === 'sliding' ||\n      this.#timeoutIds.size === 0 // new fixed window\n    ) {\n      const now = Date.now()\n      const timeUntilExpiration = executionTime - now + this.#getWindow() + 1\n      const timeoutId = setTimeout(() => {\n        this.#cleanupOldExecutions()\n        this.#clearTimeout(timeoutId)\n      }, timeUntilExpiration)\n      this.#timeoutIds.add(timeoutId)\n    }\n  }\n\n  #clearTimeout = (timeoutId: NodeJS.Timeout): void => {\n    clearTimeout(timeoutId)\n    this.#timeoutIds.delete(timeoutId)\n  }\n\n  #clearTimeouts = (): void => {\n    this.#timeoutIds.forEach((timeoutId) => clearTimeout(timeoutId))\n    this.#timeoutIds.clear()\n  }\n\n  #cleanupOldExecutions = (): void => {\n    this.#setState({\n      executionTimes: this.#getExecutionTimesInWindow(),\n    })\n  }\n\n  /**\n   * Returns the number of remaining executions allowed in the current window\n   */\n  getRemainingInWindow = (): number => {\n    const relevantExecutionTimes = this.#getExecutionTimesInWindow()\n    return Math.max(0, this.#getLimit() - relevantExecutionTimes.length)\n  }\n\n  /**\n   * Returns the number of milliseconds until the next execution will be possible\n   * For fixed windows, this is the time until the current window resets\n   * For sliding windows, this is the time until the oldest execution expires\n   */\n  getMsUntilNextWindow = (): number => {\n    if (this.getRemainingInWindow() > 0) {\n      return 0\n    }\n    const oldestExecution = this.store.state.executionTimes[0] ?? Infinity\n    return oldestExecution + this.#getWindow() - Date.now()\n  }\n\n  /**\n   * Resets the rate limiter state\n   */\n  reset = (): void => {\n    this.#setState(getDefaultAsyncRateLimiterState())\n    this.#clearTimeouts()\n  }\n}\n\n/**\n * Creates an async rate-limited function that will execute the provided function up to a maximum number of times within a time window.\n *\n * Unlike the non-async rate limiter, this async version supports returning values from the rate-limited function,\n * making it ideal for API calls and other async operations where you want the result of the `maybeExecute` call\n * instead of setting the result on a state variable from within the rate-limited function.\n *\n * The rate limiter supports two types of windows:\n * - 'fixed': A strict window that resets after the window period. All executions within the window count\n *   towards the limit, and the window resets completely after the period.\n * - 'sliding': A rolling window that allows executions as old ones expire. This provides a more\n *   consistent rate of execution over time.\n *\n * Note that rate limiting is a simpler form of execution control compared to throttling or debouncing:\n * - A rate limiter will allow all executions until the limit is reached, then block all subsequent calls until the window resets\n * - A throttler ensures even spacing between executions, which can be better for consistent performance\n * - A debouncer collapses multiple calls into one, which is better for handling bursts of events\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the rate limiter\n * - `initialState` can be a partial state object\n * - Use `onSuccess` callback to react to successful function execution and implement custom logic\n * - Use `onError` callback to react to function execution errors and implement custom error handling\n * - Use `onSettled` callback to react to function execution completion (success or error) and implement custom logic\n * - Use `onReject` callback to react to executions being rejected when rate limit is exceeded\n * - The state includes execution times, success/error counts, and current execution status\n * - State can be accessed via the underlying AsyncRateLimiter instance's `store.state` property\n * - When using framework adapters (React/Solid), state is accessed from the hook's state property\n *\n * Consider using throttle() or debounce() if you need more intelligent execution control. Use rate limiting when you specifically\n * need to enforce a hard limit on the number of executions within a time period.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and rate limiter instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together - the handler will be called before any error is thrown\n * - The error state can be checked using the underlying AsyncRateLimiter instance\n * - Rate limit rejections (when limit is exceeded) are handled separately from execution errors via the `onReject` handler\n *\n * @example\n * ```ts\n * // Rate limit to 5 calls per minute with a sliding window\n * const rateLimited = asyncRateLimit(makeApiCall, {\n *   limit: 5,\n *   window: 60000,\n *   windowType: 'sliding',\n *   onError: (error) => {\n *     console.error('API call failed:', error);\n *   },\n *   onReject: (rateLimiter) => {\n *     console.log(`Rate limit exceeded. Try again in ${rateLimiter.getMsUntilNextWindow()}ms`);\n *   }\n * });\n *\n * // First 5 calls will execute immediately\n * // Additional calls will be rejected until the minute window resets\n * // Returns the API response directly\n * const result = await rateLimited();\n *\n * // For more even execution, consider using throttle instead:\n * const throttled = throttle(makeApiCall, { wait: 12000 }); // One call every 12 seconds\n * ```\n */\nexport function asyncRateLimit<TFn extends AnyAsyncFunction>(\n  fn: TFn,\n  initialOptions: AsyncRateLimiterOptions<TFn>,\n) {\n  const rateLimiter = new AsyncRateLimiter(fn, initialOptions)\n  return rateLimiter.maybeExecute\n}\n"],"names":["Store","emitChange","parseFunctionOrValue","createKey","pacerEventClient"],"mappings":"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"}