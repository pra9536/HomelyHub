{"version":3,"file":"async-debouncer.cjs","sources":["../../src/async-debouncer.ts"],"sourcesContent":["import { Store } from '@tanstack/store'\nimport { createKey, parseFunctionOrValue } from './utils'\nimport { emitChange, pacerEventClient } from './event-client'\nimport type { AnyAsyncFunction, OptionalKeys } from './types'\n\nexport interface AsyncDebouncerState<TFn extends AnyAsyncFunction> {\n  /**\n   * Whether the debouncer can execute on the leading edge of the timeout\n   */\n  canLeadingExecute: boolean\n  /**\n   * Number of function executions that have resulted in errors\n   */\n  errorCount: number\n  /**\n   * Whether the debounced function is currently executing asynchronously\n   */\n  isExecuting: boolean\n  /**\n   * Whether the debouncer is waiting for the timeout to trigger execution\n   */\n  isPending: boolean\n  /**\n   * The arguments from the most recent call to maybeExecute\n   */\n  lastArgs: Parameters<TFn> | undefined\n  /**\n   * The result from the most recent successful function execution\n   */\n  lastResult: ReturnType<TFn> | undefined\n  /**\n   * Number of times maybeExecute has been called (for reduction calculations)\n   */\n  maybeExecuteCount: number\n  /**\n   * Number of function executions that have completed (either successfully or with errors)\n   */\n  settleCount: number\n  /**\n   * Current execution status - 'idle' when not active, 'pending' when waiting, 'executing' when running, 'settled' when completed\n   */\n  status: 'disabled' | 'idle' | 'pending' | 'executing' | 'settled'\n  /**\n   * Number of function executions that have completed successfully\n   */\n  successCount: number\n}\n\nfunction getDefaultAsyncDebouncerState<\n  TFn extends AnyAsyncFunction,\n>(): AsyncDebouncerState<TFn> {\n  return {\n    canLeadingExecute: true,\n    errorCount: 0,\n    isExecuting: false,\n    isPending: false,\n    lastArgs: undefined,\n    lastResult: undefined,\n    maybeExecuteCount: 0,\n    settleCount: 0,\n    status: 'idle',\n    successCount: 0,\n  }\n}\n\n/**\n * Options for configuring an async debounced function\n */\nexport interface AsyncDebouncerOptions<TFn extends AnyAsyncFunction> {\n  /**\n   * Whether the debouncer is enabled. When disabled, maybeExecute will not trigger any executions.\n   * Can be a boolean or a function that returns a boolean.\n   * Defaults to true.\n   */\n  enabled?: boolean | ((debouncer: AsyncDebouncer<TFn>) => boolean)\n  /**\n   * Initial state for the async debouncer\n   */\n  initialState?: Partial<AsyncDebouncerState<TFn>>\n  /**\n   * Optional key to identify this async debouncer instance.\n   * If provided, the async debouncer will be identified by this key in the devtools and PacerProvider if applicable.\n   */\n  key?: string\n  /**\n   * Whether to execute on the leading edge of the timeout.\n   * Defaults to false.\n   */\n  leading?: boolean\n  /**\n   * Optional error handler for when the debounced function throws.\n   * If provided, the handler will be called with the error and debouncer instance.\n   * This can be used alongside throwOnError - the handler will be called before any error is thrown.\n   */\n  onError?: (\n    error: unknown,\n    args: Parameters<TFn>,\n    debouncer: AsyncDebouncer<TFn>,\n  ) => void\n  /**\n   * Optional callback to call when the debounced function is executed\n   */\n  onSettled?: (args: Parameters<TFn>, debouncer: AsyncDebouncer<TFn>) => void\n  /**\n   * Optional callback to call when the debounced function is executed\n   */\n  onSuccess?: (\n    result: ReturnType<TFn>,\n    args: Parameters<TFn>,\n    debouncer: AsyncDebouncer<TFn>,\n  ) => void\n  /**\n   * Whether to throw errors when they occur.\n   * Defaults to true if no onError handler is provided, false if an onError handler is provided.\n   * Can be explicitly set to override these defaults.\n   */\n  throwOnError?: boolean\n  /**\n   * Whether to execute on the trailing edge of the timeout.\n   * Defaults to true.\n   */\n  trailing?: boolean\n  /**\n   * Delay in milliseconds to wait after the last call before executing.\n   * Can be a number or a function that returns a number.\n   * Defaults to 0ms\n   */\n  wait: number | ((debouncer: AsyncDebouncer<TFn>) => number)\n}\n\ntype AsyncDebouncerOptionsWithOptionalCallbacks = OptionalKeys<\n  AsyncDebouncerOptions<any>,\n  'initialState' | 'onError' | 'onSettled' | 'onSuccess' | 'key'\n>\n\nconst defaultOptions: AsyncDebouncerOptionsWithOptionalCallbacks = {\n  enabled: true,\n  leading: false,\n  trailing: true,\n  wait: 0,\n}\n\n/**\n * A class that creates an async debounced function.\n *\n * Debouncing ensures that a function is only executed after a specified delay has passed since its last invocation.\n * Each new invocation resets the delay timer. This is useful for handling frequent events like window resizing\n * or input changes where you only want to execute the handler after the events have stopped occurring.\n *\n * Unlike throttling which allows execution at regular intervals, debouncing prevents any execution until\n * the function stops being called for the specified delay period.\n *\n * Unlike the non-async Debouncer, this async version supports returning values from the debounced function,\n * making it ideal for API calls and other async operations where you want the result of the `maybeExecute` call\n * instead of setting the result on a state variable from within the debounced function.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and debouncer instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - Both onError and throwOnError can be used together - the handler will be called before any error is thrown\n * - The error state can be checked using the underlying store\n *\n * State Management:\n * - The debouncer uses a reactive store for state management\n * - Use `initialState` to provide initial state values when creating the async debouncer\n * - The state includes canLeadingExecute, error count, execution status, and success/settle counts\n * - State can be accessed via the `store` property and its `state` getter\n * - The store is reactive and will notify subscribers of state changes\n *\n * @example\n * ```ts\n * const asyncDebouncer = new AsyncDebouncer(async (value: string) => {\n *   const results = await searchAPI(value);\n *   return results; // Return value is preserved\n * }, {\n *   wait: 500,\n *   onError: (error) => {\n *     console.error('Search failed:', error);\n *   }\n * });\n *\n * // Called on each keystroke but only executes after 500ms of no typing\n * // Returns the API response directly\n * const results = await asyncDebouncer.maybeExecute(inputElement.value);\n * ```\n */\nexport class AsyncDebouncer<TFn extends AnyAsyncFunction> {\n  readonly store: Store<Readonly<AsyncDebouncerState<TFn>>> = new Store<\n    AsyncDebouncerState<TFn>\n  >(getDefaultAsyncDebouncerState<TFn>())\n  key: string\n  options: AsyncDebouncerOptions<TFn>\n  #abortController: AbortController | null = null\n  #timeoutId: NodeJS.Timeout | null = null\n  #resolvePreviousPromise:\n    | ((value?: ReturnType<TFn> | undefined) => void)\n    | null = null\n\n  constructor(\n    public fn: TFn,\n    initialOptions: AsyncDebouncerOptions<TFn>,\n  ) {\n    this.key = createKey(initialOptions.key)\n    this.options = {\n      ...defaultOptions,\n      ...initialOptions,\n      throwOnError: initialOptions.throwOnError ?? !initialOptions.onError,\n    }\n    this.#setState(this.options.initialState ?? {})\n\n    pacerEventClient.on('d-AsyncDebouncer', (event) => {\n      if (event.payload.key !== this.key) return\n      this.#setState(event.payload.store.state as AsyncDebouncerState<TFn>)\n      this.setOptions(event.payload.options)\n    })\n  }\n\n  /**\n   * Updates the async debouncer options\n   */\n  setOptions = (newOptions: Partial<AsyncDebouncerOptions<TFn>>): void => {\n    this.options = { ...this.options, ...newOptions }\n\n    // Cancel pending execution if the debouncer is disabled\n    if (!this.#getEnabled()) {\n      this.cancel()\n    }\n  }\n\n  #setState = (newState: Partial<AsyncDebouncerState<TFn>>): void => {\n    this.store.setState((state) => {\n      const combinedState = {\n        ...state,\n        ...newState,\n      }\n      const { isPending, isExecuting, settleCount } = combinedState\n      return {\n        ...combinedState,\n        status: !this.#getEnabled()\n          ? 'disabled'\n          : isPending\n            ? 'pending'\n            : isExecuting\n              ? 'executing'\n              : settleCount > 0\n                ? 'settled'\n                : 'idle',\n      }\n    })\n    emitChange('AsyncDebouncer', this)\n  }\n\n  /**\n   * Returns the current debouncer enabled state\n   */\n  #getEnabled = (): boolean => {\n    return !!parseFunctionOrValue(this.options.enabled, this)\n  }\n\n  /**\n   * Returns the current debouncer wait state\n   */\n  #getWait = (): number => {\n    return parseFunctionOrValue(this.options.wait, this)\n  }\n\n  /**\n   * Attempts to execute the debounced function.\n   * If a call is already in progress, it will be queued.\n   *\n   * Error Handling:\n   * - If the debounced function throws and no `onError` handler is configured,\n   *   the error will be thrown from this method.\n   * - If an `onError` handler is configured, errors will be caught and passed to the handler,\n   *   and this method will return undefined.\n   * - The error state can be checked using `getErrorCount()` and `getIsExecuting()`.\n   *\n   * @returns A promise that resolves with the function's return value, or undefined if an error occurred and was handled by onError\n   * @throws The error from the debounced function if no onError handler is configured\n   */\n  maybeExecute = async (\n    ...args: Parameters<TFn>\n  ): Promise<ReturnType<TFn> | undefined> => {\n    if (!this.#getEnabled()) return undefined\n    this.#cancelPendingExecution()\n    this.#setState({\n      lastArgs: args,\n      maybeExecuteCount: this.store.state.maybeExecuteCount + 1,\n    })\n\n    // Handle leading execution\n    if (this.options.leading && this.store.state.canLeadingExecute) {\n      this.#setState({ canLeadingExecute: false })\n      await this.#execute(...args)\n      return this.store.state.lastResult\n    }\n\n    // Handle trailing execution\n    if (this.options.trailing && this.#getEnabled()) {\n      this.#setState({ isPending: true })\n    }\n\n    return new Promise((resolve, reject) => {\n      this.#resolvePreviousPromise = resolve\n      // this.#rejectPreviousPromise = reject\n      this.#timeoutId = setTimeout(async () => {\n        // Execute trailing if enabled\n        if (this.options.trailing && this.store.state.lastArgs) {\n          try {\n            await this.#execute(...this.store.state.lastArgs)\n          } catch (error) {\n            reject(error)\n          }\n        }\n\n        // Reset state and resolve\n        this.#setState({ canLeadingExecute: true })\n        this.#resolvePreviousPromise = null\n        resolve(this.store.state.lastResult)\n      }, this.#getWait())\n    })\n  }\n\n  #execute = async (\n    ...args: Parameters<TFn>\n  ): Promise<ReturnType<TFn> | undefined> => {\n    if (!this.#getEnabled()) return undefined\n    this.#abortController = new AbortController()\n    try {\n      this.#setState({ isExecuting: true })\n      const result = await this.fn(...args) // EXECUTE!\n      this.#setState({\n        lastResult: result,\n        successCount: this.store.state.successCount + 1,\n      })\n      this.options.onSuccess?.(result, args, this)\n    } catch (error) {\n      this.#setState({\n        errorCount: this.store.state.errorCount + 1,\n      })\n      this.options.onError?.(error, args, this)\n      if (this.options.throwOnError) {\n        throw error\n      }\n    } finally {\n      this.#setState({\n        isExecuting: false,\n        isPending: false,\n        lastArgs: undefined,\n        settleCount: this.store.state.settleCount + 1,\n      })\n      this.#abortController = null\n      this.options.onSettled?.(args, this)\n    }\n    return this.store.state.lastResult\n  }\n\n  /**\n   * Processes the current pending execution immediately\n   */\n  flush = async (): Promise<ReturnType<TFn> | undefined> => {\n    if (this.store.state.isPending && this.store.state.lastArgs) {\n      this.#abortExecution() // abort any current execution\n      this.#clearTimeout() // clear any existing timeout\n      const result = await this.#execute(...this.store.state.lastArgs)\n\n      // Resolve any pending promise from maybeExecute\n      this.#resolvePreviousPromiseInternal()\n\n      return result\n    }\n    return undefined\n  }\n\n  #resolvePreviousPromiseInternal = (): void => {\n    if (this.#resolvePreviousPromise) {\n      this.#resolvePreviousPromise(this.store.state.lastResult)\n      this.#resolvePreviousPromise = null\n    }\n  }\n\n  #clearTimeout = (): void => {\n    if (this.#timeoutId) {\n      clearTimeout(this.#timeoutId)\n      this.#timeoutId = null\n    }\n  }\n\n  #cancelPendingExecution = (): void => {\n    this.#clearTimeout()\n    this.#resolvePreviousPromiseInternal()\n    this.#setState({\n      isPending: false,\n      isExecuting: false,\n      lastArgs: undefined,\n    })\n  }\n\n  #abortExecution = (): void => {\n    if (this.#abortController) {\n      this.#abortController.abort()\n      this.#abortController = null\n    }\n  }\n\n  /**\n   * Cancels any pending execution or aborts any execution in progress\n   */\n  cancel = (): void => {\n    this.#cancelPendingExecution()\n    this.#abortExecution()\n    this.#setState({ canLeadingExecute: true })\n  }\n\n  /**\n   * Resets the debouncer state to its default values\n   */\n  reset = (): void => {\n    this.#setState(getDefaultAsyncDebouncerState<TFn>())\n  }\n}\n\n/**\n * Creates an async debounced function that delays execution until after a specified wait time.\n * The debounced function will only execute once the wait period has elapsed without any new calls.\n * If called again during the wait period, the timer resets and a new wait period begins.\n *\n * Unlike the non-async Debouncer, this async version supports returning values from the debounced function,\n * making it ideal for API calls and other async operations where you want the result of the `maybeExecute` call\n * instead of setting the result on a state variable from within the debounced function.\n *\n * Error Handling:\n * - If an `onError` handler is provided, it will be called with the error and debouncer instance\n * - If `throwOnError` is true (default when no onError handler is provided), the error will be thrown\n * - If `throwOnError` is false (default when onError handler is provided), the error will be swallowed\n * - The error state can be checked using the underlying AsyncDebouncer instance\n * - Both onError and throwOnError can be used together - the handler will be called before any error is thrown\n *\n * State Management:\n * - Uses TanStack Store for reactive state management\n * - Use `initialState` to provide initial state values when creating the async debouncer\n * - Use `onSuccess` callback to react to successful function execution and implement custom logic\n * - Use `onError` callback to react to function execution errors and implement custom error handling\n * - Use `onSettled` callback to react to function execution completion (success or error) and implement custom logic\n * - The state includes canLeadingExecute, error count, execution status, and success/settle counts\n * - State can be accessed via `asyncDebouncer.store.state` when using the class directly\n * - When using framework adapters (React/Solid), state is accessed from `asyncDebouncer.state`\n *\n * @example\n * ```ts\n * const debounced = asyncDebounce(async (value: string) => {\n *   const result = await saveToAPI(value);\n *   return result; // Return value is preserved\n * }, {\n *   wait: 1000,\n *   onError: (error) => {\n *     console.error('API call failed:', error);\n *   },\n *   throwOnError: true // Will both log the error and throw it\n * });\n *\n * // Will only execute once, 1 second after the last call\n * // Returns the API response directly\n * const result = await debounced(\"third\");\n * ```\n */\nexport function asyncDebounce<TFn extends AnyAsyncFunction>(\n  fn: TFn,\n  initialOptions: AsyncDebouncerOptions<TFn>,\n) {\n  const asyncDebouncer = new AsyncDebouncer(fn, initialOptions)\n  return asyncDebouncer.maybeExecute\n}\n"],"names":["Store","emitChange","parseFunctionOrValue","createKey","pacerEventClient"],"mappings":"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"}